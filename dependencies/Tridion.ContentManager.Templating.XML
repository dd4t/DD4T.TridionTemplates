<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tridion.ContentManager.Templating</name>
    </assembly>
    <members>
        <member name="T:Tridion.ContentManager.Templating.Assembly.AssemblyCache">
            <summary>
            AppDomain-wide caching mechanism for .NET assemblies (incl. compiled C# fragments)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.CreateAssemblyKey(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Create a assembly key for a given Template version, which is unique for the specific version.
            </summary>
            <param name="template">The Template (version) for which to get a cache key.</param>
            <returns>The assembly key used to cache an assembly for the given Template version.</returns>
            <remarks>
            Only one assembly can be cached per Template version, although "transient state" for Templates is also supported.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.GetCachedTemplateProcessor(System.String,System.String)">
            <summary>
            Gets a cached template processor, if available.
            </summary>
            <param name="assemblyKey">The key for the Assembly.</param>
            <param name="className">The name of the class to instantiate (or null for the default)</param>
            <returns>An template instance or <c>null</c> if no assembly was cached for the given subject.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.AddAssembly(System.String,System.Reflection.Assembly)">
            <summary>
            Adds an Assembly to the cache.
            </summary>
            <param name="assemblyKey">The key for the Assembly.</param>
            <param name="assembly">The Assembly to cache.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.GetTemplateType(System.Reflection.Assembly,System.String)">
            <summary>
            Construct a Type from an assembly byte array.
            </summary>
            <param name="templateAssembly">The assembly to get the type from</param>
            <param name="className">The name of the class implementing to return. If you pass null for the
            class name, the method will return the first class it can find that implementes the ITemplate 
            interface</param>
            <returns>
            An object implementating the (Assembler.)ITemplate interface, derived
            from the template object. The object is based on a type loaded from
            an external assembly. Never null.
            </returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the assembly could not be loaded,
            or the template requested could not be found</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.FindTemplateTypeInAssembly(System.Reflection.Assembly)">
            <summary>
            Find a type in the assembly that implements the ITemplate interface, with
            a preference for classes with a TcmDefaultTemplate attribute specified on
            them.
            </summary>
            <param name="templateAssembly">The assembly containing the template classes</param>
            <returns>A type implementing ITemplate, or null if there is no such type in
            the assembly</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.AssemblyCache.CacheSize">
            <summary>
            Gets the current cache size
            </summary>
            <remarks>
            For unit testing purposes.
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.AssemblyCache.LockObject">
            <summary>
            Gets a lock object which should be used to prevent race conditions when adding stuff to the cache.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.AssemblyCache.CachedAssemblyInfo">
            <summary>
            Information element on a cached assembly (including all the types it contains).
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.CachedAssemblyInfo.#ctor(System.Reflection.Assembly)">
            <summary>
            Constructor
            </summary>
            <param name="assembly">The assembly to represent</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.CachedAssemblyInfo.GetTemplate(System.String)">
            <summary>
            Get a template based on a specific classname (or for the default template).
            </summary>
            <param name="className">The name of the class to retrieve from the template,
            or null if the default (or only) template should be retrieved</param>
            <returns>Always returns an instantiated template, never returns null</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case a template cannot be found</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyCache.CachedAssemblyInfo.GetTypes">
            <summary>
            Gets the types defined in cached assembly.
            </summary>
            <returns>Array of types.</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.CachingSource">
            <summary>
            Simple wrapper around an ISource object, that caches the earlier resolved queries
            </summary>
            <remarks>
            This class should only be used with sources whose identities do not change. It is possible
            to reset the cache in case of changes to the source.
            </remarks>
        </member>
        <member name="T:Tridion.ContentManager.Templating.ISource">
            <summary>
            Interface for accessing items as a (possibly nested) text-source of information.
            </summary>
            <remarks>
            <para>
            Templating uses a very simple 'source expression language' to access information sources
            through an expression. The source expressions are called 'qualified names', because usually
            they will consist of a number of names, e.g. <c>major.minor.subname</c>.
            </para>
            <para>
            The <c>ISource</c> interface is meant to be an abstraction, so how the qualified names
            are processed depends on the underlying object. Some <c>ISource</c> implementations 
            allow for indexed access, e.g. major[1].minor.subname[3] but this need not be implemented.
            </para>
            <para>
            The most important <c>ISource</c> implementations are <see cref="T:Tridion.ContentManager.Templating.Package"/> and <see cref="T:Tridion.ContentManager.Templating.Item"/>.
            The <c>Package</c> is especially important, in case an <c>@@...@@</c> expression is evaluated in Dreamweaver
            value expressions are treated on the package.
            </para>
            <para>
            The main access method is <see cref="M:Tridion.ContentManager.Templating.ISource.GetValue(System.String)"/>. Because a source expression can
            contain steps that may return multiple results, it is possible to get the matching sources
            for a sub-expression through <see cref="M:Tridion.ContentManager.Templating.ISource.GetSources(System.String)"/>. All source-values are eventually
            returned as a string, but it is possible to find the underlying type through 
            <see cref="M:Tridion.ContentManager.Templating.ISource.GetContentType"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ISource.GetValue(System.String)">
            <summary>
            Determine the string value for a source.
            </summary>
            <param name="fullyQualifiedName">The name to get the source for</param>
            <returns>The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ISource.GetSources(System.String)">
            <summary>
            Retrieve the (list of) subsource(s) of a source. The returned subsource(s)
            can be used again to drill down the expression further.
            
            For example, if calling 
            	<c>GetValue("Component.Schema.ID")</c> 
            on a source would return a value, calling
            	<c>GetSources("Component.Schema")[0].GetValue("ID")</c>
            would result in the same.
            </summary>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of subsources that match the partially qualified name. Most implementations
            of this method will not return all possible matches, but just the list of sources of the first
            match found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ISource.GetContentType">
            <summary>
            The content type associated with the current source.
            </summary>
            <returns>The content type of this source (not allowed to be null in implementations)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.CachingSource.#ctor(Tridion.ContentManager.Templating.ISource)">
            <summary>
            Constructor
            </summary>
            <param name="wrappedSource">The source to cache</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.CachingSource.ResetCache">
            <summary>
            Reset the cache for this source (in case the wrapped source may have different content)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.CachingSource.GetValue(System.String)">
            <summary>
            Determine the string value for a source.
            </summary>
            <param name="fullyQualifiedName">The name to get the source for</param>
            <returns>The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.CachingSource.GetSources(System.String)">
            <summary>
            Retrieve the (list of) subsource(s) of a source. The returned subsource(s)
            can be used again to drill down the expression further.
            
            For example, if calling GetValue("Component.Schema.ID") on a source
            would return a value, calling
            	GetSources("Component.Schema")[0].GetValue("ID")
            would result in the same.
            </summary>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of subsources that match the partially qualified name. Most implementations
            of this method will not return all possible matches, but just the list of sources of the first
            match found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.CachingSource.GetContentType">
            <summary>
            ISource implementation: Determine the content type of this source
            </summary>
            <returns>The content type of the wrapped source</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.DefaultTemplatesScriptCollection">
             <summary>
             Configuration class to represent default templates setup scripts, which can  be run from Template Builder.
             </summary>
             <example>
            <defaultTemplatesScripts>
              <defaultTemplatesScript scriptFile="default_templates_setup.xml" />
            </defaultTemplatesScripts>
             </example>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.DefaultTemplatesScriptCollection.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.DefaultTemplatesScriptCollection.CreateNewElement">
            <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"/>.
            </summary>
            <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"/>.
            </returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.DefaultTemplatesScriptCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
            <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"/> to return the key for.</param>
            <returns>
            An <see cref="T:System.Object"/> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"/>.
            </returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.DefaultTemplatesScriptElement.ScriptFile">
            <summary>
            File path of templates setup script
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.DefaultTemplatesScriptElement.ParameterCollection">
            <summary>
            Gets and sets the Parameter-collection property
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.FunctionSourceCollection">
            <summary>
            Configuration class to represent function sources available to expression evaluation.
            </summary>
            <example>
            <functionSources>
                <functionSource type="Tridion.ContentManager.Templating.Expression.BuiltInFunctions" />
                <functionSource type="Tridion.ContentManager.Templating.Expression.OutboundEmailExpressionEvaluator" assembly="D:\cvs\Outbound E-Mail\Source\ManagementSystem\DotNet\Tridion.OutboundEmail.Templating.Templates\Templating\bin\Debug\Tridion.OutboundEmail.Templating.dll" />
            </functionSources>
            </example>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.FunctionSourceCollection.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.FunctionSourceCollection.CreateNewElement">
            <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"/>.
            </summary>
            <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"/>.
            </returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.FunctionSourceCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
            <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"/> to return the key for.</param>
            <returns>
            An <see cref="T:System.Object"/> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"/>.
            </returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.FunctionSourceElement.ClassName">
            <summary>
            Property for the classname
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.FunctionSourceElement.Assembly">
            <summary>
            Optional property for assembly path of the mediator.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.FunctionSourceElement.ParameterCollection">
            <summary>
            Gets and sets the Parameter-collection property
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.ParameterCollection">
            <summary>
            Configuration class to represent a list of ParameterElements
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.ParameterCollection.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.ParameterCollection.CreateNewElement">
            <summary>
            Creates a new ParameterElement.
            </summary>
            <remarks>
            Part of ConfigurationElementCollection implementation.
            </remarks>
            <returns>A new ParameterElement</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.ParameterCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Determine the key of a specific configuration element.
            </summary>
            <remarks>
            Part of ConfigurationElementCollection implementation.
            </remarks>
            <param name="element">The Parameter to determine the key for</param>
            <returns>A determined key-value for this configuration element</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.ParameterCollection.GetValue(System.String)">
            <summary>
            Get a parameter value, or null if no such parameter is defined
            </summary>
            <param name="name">The name of the parameter to retrieve</param>
            <returns>The value of the parameter, or null if the parameter does not exist</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.ParameterCollection.Add(Tridion.ContentManager.Templating.Configuration.ParameterElement)">
            <summary>Add a ParameterElement to this ParameterCollection</summary>
            <remarks>For testing</remarks>
            <param name="parameter">The parameter to add</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.ParameterElement">
            <summary>
            Configuration class to represent one parameter, which has the syntax
            	<parameter name="ParameterName" value="Value" />
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.ParameterElement.#ctor">
            <summary>
            Constructor (used from ParameterCollection)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.ParameterElement.#ctor(System.String,System.String)">
            <summary>
            Constructor (for testing)
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="value">The value of the parameter</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.ParameterElement.Name">
            <summary>
            Property for the name of the parameter
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.ParameterElement.Value">
            <summary>
            Property for the value of the parameter
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.Debugger">
            <summary>
            Interface to DebuggingEngine for WebServices
            </summary>
            <remarks>
            This is not meant as a public class for customers, it is only meant to be used
            by the Compound Template IDE WebService.
            Meant for state-less access, where this object keeps the state. A session-id
            is used to access a specific instance.
            The general usage of this class in pseudocode would be
            string sessionId = Debugger.NewDebugger(compoundTemplateContent, itemUri, true, null, null);
            Debugger.Start(sessionId);
            while (Debugger.IsRunning(sessionId))
            {
                Do something with Debugger.GetExecutionStatusXml(sessionId)
            }
            if (Debugger.GetLastException(sessionId) != null)
            {
                Report Failure
            }
            Debugger.Close(sessionId);
            where GetPackageXml GetPackageItemXml can be used to get further information
            on 
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.Initialize(System.String)">
            <summary>
            Perform the initialization needed for a user, when he/ she first logs on
            in the template builder.
            </summary>
            <remarks>
            The amount of work you can do here is very limited. It is e.g. not possible to
            initialize any static variables, as the process running this code may be reset.
            </remarks>
            <param name="userName">The user to initialize for</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.DeInitialize(System.String)">
            <summary>
            Perform the de-initialization needed for a user, when he/ she first logs off
            from the template builder.
            </summary>
            <param name="userName">The user to deinitialize for</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.StartNewDebuggerForItemUri(System.String,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.Diagnostics.TraceEventType)">
            <summary>
            Create a new debugger object, and start the debugging session.
            </summary>
            <remarks>
            Every caller of this method should ensure to also call the Close-method with 
            the generated session id, to ensure proper cleanup of sessions.
            </remarks>
            <param name="compoundTemplateUri">The URI of the (possibly new) compound template to execute</param>
            <param name="compoundTemplateContent">The compound template to execute</param>
            <param name="itemUri">The page or component to execute the template on</param>
            <param name="preview">Where the rendering should occur as preview or render</param>
            <param name="publicationTargetUri">The (optional) publication target that the template would be executed for</param>
            <param name="userName">The (optional) user the template execution should occur as. If not set, the user name is taken from the context</param>
            <param name="logTridionClasses">Whether or not log-messages for standard Tridion classes should be logged</param>
            <param name="logLevel">The level of logging to include</param>
            <returns>The sessionId that should be used to access the new debugger further</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.StartNewDebuggerForPackage(System.String,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.Diagnostics.TraceEventType)">
            <summary>
            Create a new debugger object, and start the debugging session.
            </summary>
            <remarks>
            Every caller of this method should ensure to also call the Close-method with 
            the generated session id, to ensure proper cleanup of sessions.
            </remarks>
            <param name="compoundTemplateUri">The URI of the (possibly new) compound template to execute</param>
            <param name="compoundTemplateContent">The compound template to execute</param>
            <param name="packageContents">The serialized package Xml to execute the template on</param>
            <param name="preview">Where the rendering should occur as preview or render</param>
            <param name="publicationTargetUri">The (optional) publication target that the template would be executed for</param>
            <param name="userName">The (optional) user the template execution should occur as. If not set, the user name is taken from the context</param>
            <param name="logTridionClasses">Whether or not log-messages for standard Tridion classes should be logged</param>
            <param name="logLevel">The level of logging to include</param>
            <returns>The sessionId that should be used to access the new debugger further</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.StartNewDebugger(System.String,System.String,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.Diagnostics.TraceEventType)">
            <summary>
            Helper for StartNewDebuggerFor...
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.DeterminePreviewLocations(System.String@,System.String@)">
            <summary>
            Helper routine to determine the base URLs and directory used for the preview location,
            based on the current HttpContext
            </summary>
            <param name="previewBaseDirectory">The out parameter for the found preview directory</param>
            <param name="previewBaseUrl">The out parameter for the found preview url</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.Stop(System.String,System.String)">
            <summary>
            Hard-stop the debugging process.
            </summary>
            <remarks>
            This should only be called in exceptional circumstances, normally
            the templating will stop by itself. An attempt is made to stop
            the thread, as well as output to the package directory.
            </remarks>
            <param name="userName">The name of the user this session belongs to</param>
            <param name="sessionId">The id of the debug session this method should operate on</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.Close(System.String,System.String)">
            <summary>
            Close the session, the sessionid may not be used anymore after this call.
            </summary>
            <remarks>
            Every created session should be closed to clean up its resources
            </remarks>
            <param name="userName">The name of the user performing this close action</param>
            <param name="sessionId">The id of the debug session this method should operate on</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.IsRunning(System.String)">
            <summary>
            Check whether a templating action is still running, after start has been called.
            </summary>
            <param name="sessionId">The id of the debug session this method should operate on</param>
            <returns>Whether or not the templating execution is currently still active.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetLastException(System.String)">
            <summary>
            Get the exception thrown from templating, if there was one.
            </summary>
            <remarks>
            This is the only method that can be used to determine whether
            an error occurred.
            </remarks>
            <param name="sessionId">The id of the debug session this method should operate on</param>
            <returns>The exception that stopped the template execution as a string (including stacktraces
            and inner exceptions), or null in case there was no exception (could be that exception 
            occurs later)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetExecutionStatusXml(System.String)">
            <summary>
            Get the current execution status XML document as a string
            </summary>
            <param name="sessionId">The id of the debug session this method should operate on</param>
            <returns>Null in case there have been no invocations yet. Otherwise
            contains information on all the invocations that have been active so far.
            An invocation is only complete if it has a duration.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetPackageXml(System.String,System.String)">
            <summary>
            Get the XML contents of a package.
            </summary>
            <param name="sessionId">The id of the debug session this method should operate on</param>
            <param name="name">The name of the package to retrieve. The names are present in the 
            GetExecutionStatusXml document</param>
            <returns>The package xml</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case no package with such a name exists</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetPackageItemXml(System.String,System.String)">
            <summary>
            Get the XML contents of a package item.
            </summary>
            <param name="sessionId">The id of the debug session this method should operate on</param>
            <param name="name">The unique name of the item to retrieve. The names are present in the 
            GetPackageXml documents</param>
            <returns>The item data within an xml element</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case no item with such a name exists</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetLogMessagesXml(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the logging messages Xml of the currently active session.
            (output may be updated as template runs)
            </summary>
            <param name="sessionId">The id of the debug session this method should operate on</param>
            <param name="templateInvocationId">The template invocation to retrieve messages for (-1 for all invocations)</param>
            <param name="startId">The first message to retrieve (-1 for the first matching messages)</param>
            <param name="maxCount">The maximum amount of messages to retrieve (-1 for all matches)</param>
            <returns>The log messages within the invocations in an XML format (all known invocations are always present
            the messages only those that match the filter)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetDebugSession(System.String)">
            <summary>
            Internal method to get a specific session
            </summary>
            <param name="sessionId">The id of the debug session to retrieve</param>
            <returns>The debug session</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the session id is unknown</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetWorkingDirectory">
            <summary>
            Determine the working directory to create debugging folders in
            </summary>
            <returns>The working directory, if not configured defaults to the temporary directory</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetWebServiceDirectory">
            <summary>
            Determine the webservice directory, based on the current request information
            (the webservice asmx file is expected to reside in the home directory of the webservice).
            </summary>
            <returns>The determined webservice home directory</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetRemoteDebugger(System.String)">
            <summary>
            Get Remote debugger object (so an object retrieved through remoting) for
            the given username. Also starts the remote process if not already running.
            </summary>
            <param name="userName">The name of the user to log on as</param>
            <returns>The remote debugger object</returns>
            <exception cref="T:System.Exception">In case of any issues getting the remote object</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.GetRemoteDebugger(System.String,System.String)">
            <summary>
            Get Remote debugger object (so an object retrieved through remoting) for
            the given username. Also starts the remote process if not already running.
            </summary>
            <param name="userName">The name of the user to log on as</param>
            <param name="webServiceDirectory">The directory where the webservice resides</param>
            <returns>The remote debugger object</returns>
            <exception cref="T:System.Exception">In case of any issues getting the remote object</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.StartDebuggingRunnerProcess(System.String,System.String)">
            <summary>
            Start a new TemplatingDebuggingRunner.exe process
            </summary>
            <param name="userName">The name of the user to connect as</param>
            <returns>The connection url that the new process can be accessed under for remoting</returns>
            <param name="webServiceDirectory">The directory where the webservice resides</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.ConstructRemoteName(System.String)">
            <summary>
            Create a string (without non-ASCII characters) representing a unique identification
            of a user by name (used in Remoting identifiers and filenames)
            </summary>
            <param name="userName">The username input</param>
            <returns>A string representation of that username without non-ASCII characters</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.Debugger.InitializeThread">
            <summary>
            Helper class for Initialize method. Since no errors on failing to start
            the remote debugger process are reported, this may as well be done in a separate
            thread to not slow down logging on.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.Debugger.InitializeThread.Run">
            <summary>
            The run-method of the new thread
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.DebuggerRemoteRunner">
            <summary>
            Singleton class that acts as the remoting object shared between the debugging webservices
            and the DebuggingRunner separate executable.
            </summary>
            <remarks>
            This object is created/ registered in TemplatingDebugRunner, and used from the Debugger class.
            The main method is StartDebugger, there are some utility methods to stop the last started
            debug session and to control usage of this singleton.
            
            Since the whole point of this class is that the process this class operates in can be suspended
            for debugging, so methods should only be called on this object if it can be assumed the Debugger is
            currently not suspended (for example, the Stop call and the Exit call may be blocked).
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Debugging.DebuggerRemoteRunner.CommandStartedPrefix">
            <summary>
            The prefix format of the command line tool TemplatingDebugRunner to indicate
            what port it is running on
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggerRemoteRunner.ShouldQuit">
            <summary>
            The lifetime of this process is limited, this method is called to determine
            whether the process this remoting object lives in should be stopped.
            </summary>
            <returns>true in case the process should quit, false if it should continue</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggerRemoteRunner.StartDebugger(System.String,System.String,System.String,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.String,System.String,System.String)">
            <summary>
            Start a debugger in a new thread.
            </summary>
            <param name="sessionId">The session id of the to be created debug session</param>
            <param name="compoundTemplateUri">The URI of the (possibly new) compound template to execute</param>
            <param name="compoundTemplateContent">see DebugSession constructor</param>
            <param name="itemUri">see DebugSession constructor</param>
            <param name="packageContents">see DebugSession constructor</param>
            <param name="preview">see DebugSession constructor</param>
            <param name="publicationTargetUri">see DebugSession constructor</param>
            <param name="userName">The user this debug session is initiated for</param>
            <param name="logTridionClasses">see DebugSession constructor</param>
            <param name="logLevelString">see DebugSession constructor</param>
            <param name="previewDirectory">The preview directory of this CMS</param>
            <param name="previewUrl">The preview base URL of this CMS</param>
            <returns>In case of an exception, that exception may not be serialisable. So in case
            of a non-null result, the return value should be treated as an error message</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggerRemoteRunner.Ping">
            <summary>
            Method to check whether the remote object can be used (which it cannot be if the
            process has exited).
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggerRemoteRunner.Stop(System.String)">
            <summary>
            Attempt to stop a session, which should always be the last session invoked
            (we could keep a list, but this remote object exists per user, and per user
            we only expect one debugging session).
            </summary>
            <param name="sessionId"></param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggerRemoteRunner.Exit">
            <summary>
            Indicate this process should stop.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.DebuggingEngine">
            <summary>
            Specific engine implementation for debugging
            </summary>
            <remarks>
            This version of the engine is special in that:
             - The outputs are written to a special debugging directory.
             - Packages and invocation information is also written to that directory.
             - The assumption is that the template execution always starts with a compound template,
            where the compound template is taken from memory (with the InMemoryCompoundTemplate template).
            
            The template is executed in a separate thread, where the original thread can inspect the current
            status of the execution.
            </remarks>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Engine">
            <summary>
            Templating Engine, context for the templating code.
            </summary>
            <remarks>
            <para>The engine is responsible for acting as API for template rendering
            and mediators, invoking mediators, and giving an API to mediators
            and templates.</para>
            <para>IMPORTANT NOTE: Since an Engine aggregates a <see cref="T:Tridion.ContentManager.Session"/>, it has the same limitations with regards to threading.
            In particular, Engine objects may only be used on a single (STA) thread. Never share Engine objects across threads.</para>
            <para>This object is available in implementations of <see cref="T:Tridion.ContentManager.Templating.Assembly.ITemplate"/> and under the
            name <c>engine</c> within C# fragment templates.</para>
            <para>
            See the <a href="/Overview/Templating concepts/Engine.html">'template resources'</a> 
            section in the overview for more information on what kind of information can be accessed
            through the engine, and the <a href="/Overview/Handling Pages/dotnet_templates.html">example template</a> 
            for some example usage.
            </para>
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Engine._session">
            <summary>
            The Tom.Net session to work with
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.#ctor">
            <exclude/>
            <summary>
            Constructor, for internal use only (this is an abstract class)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetSession">
            <summary>
            Get the TOM.NET session used in this engine context
            </summary>
            <returns>The active session used in this engine object</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.SetPublishingContext(Tridion.ContentManager.Templating.PublishingContext)">
            <summary>
            Set the value of the PublishingContext property
            </summary>
            <param name="publishingContext">The new value for the PublishingContext property</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetTridionXml(Tridion.ContentManager.TcmUri)">
            <summary>
            Public API to get the XML-content for a Tridion object as a string.
            </summary>
            <param name="itemUri">The URI of the item to retrieve</param>
            <returns>The string representation of the the Tridion item, or null if the
            item could not be retrieved</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetTridionXml(System.String)">
            <summary>
            Public API to get the XML-content for a Tridion object as a string, based
            on a WebDAV URL.
            </summary>
            <param name="webDavUrlOrItemUri">The WebDAV URL or TCM URI of the item to retrieve</param>
            <returns>The string representation of the the Tridion item, or null if the
            item could not be retrieved</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetObject(Tridion.ContentManager.TcmUri)">
            <summary>
            Shortcut to <see cref="M:Tridion.ContentManager.Session.GetObject(System.String)"/>.
            </summary>
            <param name="uri">The URI for which to get the object</param>
            <returns>The Tom.Net tridion object for the specified URI, or null if it could not be found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetObject(System.String)">
            <summary>
            Shortcut to <see cref="M:Tridion.ContentManager.Session.GetObject(System.String)"/>.
            </summary>
            <param name="itemUriOrWebDavUrl">Either the TCM URI or the WebDAV URL to retrieve</param>
            <returns>The Tom.Net tridion object for the specified URI/ WebDAV URL, or null if it could not be found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetObject(Tridion.ContentManager.Session,System.String)">
            <summary>
            Access to Session.GetObject, through the engine
            </summary>
            <param name="session">The session to call GetObject on</param>
            <param name="itemUriOrWebDavUrl">Either the TCM URI or the WebDAV URL to retrieve</param>
            <returns>The Tom.Net tridion object for the specified URI/ WebDAV URL, or null if it could not be found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.ExecuteTemplate(Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            Applies the given template to the package.
            </summary>
            <param name="template">The template to apply to the package</param>
            <param name="package">The package to apply the template to</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetMediator(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Determine and initialize a mediator for a template.
            </summary>
            <param name="template">The template to determine the mediator for</param>
            <returns>A fully initialized mediator (throws an exception if this is not possible)</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">Thrown when no mediator could be found for the given template.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetConfiguration">
            <summary>
            Get the configuration of Templating, based on the <c>Tridion.ContentManager.config</c> file contents.
            </summary>
            <returns>The configuration</returns>
            <exception cref="T:Tridion.Configuration.ConfigurationException">In case the configuration could not be determined</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.RegisterTemplateInvocationListener(Tridion.ContentManager.Templating.ITemplateInvocationListener)">
            <summary>
            Registers the given listener to be notified of templates that are invoked by this engine.
            </summary>
            <param name="listener">The listener to be notified of template invocations</param>
            <exception cref="T:Tridion.TridionArgumentException">Throws an TridionArgumentException when the same listener object has already been registered before.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.UnregisterTemplateInvocationListener(Tridion.ContentManager.Templating.ITemplateInvocationListener)">
            <summary>
            Unregisters the given listener from receiving template invocation invocations by this engine.
            </summary>
            <param name="listener">The listener to no longer be notified of template invocations</param>
            <exception cref="T:Tridion.TridionArgumentException">Throws an TridionArgumentException when the given listener object has not been registered or has already been unregistered.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.InvokeTemplate(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            Invokes the specified template on the given package.
            </summary>
            <param name="package">The package containing the potential input and output for the template.</param>
            <param name="templateInvocation">The template to invoke and the parameters to pass.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.InvokeTemplate(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation,Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Invokes the specified template on the given package.
            </summary>
            <param name="package">The package containing the potential input and output for the template.</param>
            <param name="templateInvocation">Information on the template to invoke and the parameters to pass.</param>
            <param name="template">Explicit reference to the template to invoke</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.ConstructParameterItems(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation,Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Construct a map of items representing the parameters of this template invocation
            </summary>
            <param name="package">The package to construct the items on</param>
            <param name="templateInvocation">The invocation that may contain parameter values</param>
            <param name="template">The template, with a possible parameter schemas</param>
            <returns>A map of items representing the parameters</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetTemplate(Tridion.ContentManager.TcmUri)">
            <summary>
            Gets the requested template item from Tridion Content Manager.
            </summary>
            <param name="templateURI">The URI of the template to retrieve.</param>
            <returns>the template object for the given TCM URI</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.CreateMultimediaItem(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.TcmUri)">
            <summary>
            Utility method for usage by package (since multiple TOM accesses are necessary,
            it is inconvenient to perform these actions in Package class).
            Resolve a multimedia component, and construct an item based on its data.
            </summary>
            <param name="package">The package to create the item on</param>
            <param name="componentUri">The URI of the multimedia component to create the item for</param>
            <returns>A newly created item for the component</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.CreateMultimediaItem(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.ContentManagement.Component)">
            <summary>
            Utility method for usage by package (since multiple TOM accesses are necessary,
            it is inconvenient to perform these actions in Package class).
            Resolve a multimedia component, and construct an item based on its data.
            </summary>
            <param name="package">The package to create the item on</param>
            <param name="component">The multimedia component to create the item for</param>
            <returns>A newly created item for the component</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.LocalizeUri(Tridion.ContentManager.TcmUri)">
            <summary>
            Localizes the publication uri of a TcmUri if a context publication uri is available. 
            </summary>
            <remarks>
            A context publication uri will not be available when debugging with a package only.
            </remarks>
            <param name="uriToLocalize">URI to localize</param>
            <returns>The localized uri if a context publication is available</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetContextPublicationUri">
            <summary>
            Method that determines the current publication where engine is excecuting within.
            </summary>
            <returns>The Tcm URI of the context publication, or null if thise cannot be determined</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.RenderComponentPresentation(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri)">
            <summary>
            Render a component presentation, using the RenderEngine.
            </summary>
            <remarks>
            The component presentation is also registered for the current page (so that it
            is known the component presentation appears on the page).
            </remarks>
            <param name="componentUri">The component to render</param>
            <param name="componentTemplateUri">The template to use in rendering</param>
            <returns>The content of the rendered component presentation</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.IsTemplateDynamic(Tridion.ContentManager.CommunicationManagement.ComponentTemplate)">
            <summary>
            Should this component template be handled as dynamic (there can be
            various reasons not to do this even if the template itself is dynamic).
            </summary>
            <param name="template">The component template to inspect</param>
            <returns>Whether the template should be rendered in dynamic fashion</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.IsTemplateRenderedExternally(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Returns true when the template will not be rendered by .Net templating (e.g. when it is vbscript, jscript etc)
            </summary>
            <param name="template">ComponentTemplate to determine rendering status for</param>
            <returns>true when the template will not be with a .Net template mediator</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetMainRenderedItem">
            <summary>
            Return the rendered item whose context this Engine object exists in.
            </summary>
            <returns>The context RenderedItem, or null if there is no such item.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.SetupRenderInstruction(Tridion.ContentManager.Publishing.RenderInstruction)">
            <summary>
            Utility method for RenderComponentPresentation, to set up a new RenderInstruction.
            Implemented in Engine subclasses.
            </summary>
            <param name="renderInstruction">The render instruction to set up</param>
            <returns>The publication target that should be used in rendering</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.ReadRenderedItemContent(Tridion.ContentManager.Publishing.Rendering.RenderedItem)">
            <summary>
            Read the string content of a rendered item.
            </summary>
            <remarks>
            This function is performed in a non-destructive way.
            </remarks>
            <param name="renderedItem">The current rendered item</param>
            <returns>The current content of the rendered item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.TransformItem(Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.IdentifiableObject)">
            <summary>
            Perform a render transformation based on a component or page.
            </summary>
            <param name="template">The template to render the item with</param>
            <param name="itemToRender">The page or component to render</param>
            <returns>The resulting output item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.TransformSerializedPackage(Tridion.ContentManager.CommunicationManagement.Template,System.Xml.XmlDocument)">
            <summary>
            Perform a render transformation based on serialized package.
            </summary>
            <param name="template">The template to render the item with</param>
            <param name="packageToProcess">The package to render</param>
            <returns>The resulting output item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.TransformPackage(Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            Helper routine for the TransformItem methods, to perform a top level
            template execution
            </summary>
            <param name="template">The template to execute</param>
            <param name="package">The package to process</param>
            <returns>The resulting output item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.CheckInitialized">
            <summary>
            Check whether this Engine object can be used.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.AddBinary(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri,System.Byte[],System.String)">
            <summary>
            Publish a binary from a byte-array with a given filename, associated with a multimedia
            component and possibly saved as a variant (the template uri acts as a variant).
            </summary>
            <remarks>
            For more AddBinary alternatives, use 
            Engine.PublishingContext.<see cref="T:Tridion.ContentManager.Publishing.Rendering.RenderedItem"/>.AddBinary(...).
            </remarks>
            <param name="componentUri">The multimedia component this item refers to</param>
            <param name="templateUri">The template in whose context this AddBinary call is executed (used as variant id)</param>
            <param name="targetLocation">The location to publish the binary to (if null, publish to standard path)</param>
            <param name="data">The binary data to publish</param>
            <param name="fileName">The filename to publish the file under</param>
            <returns>The path of the binary as it was published to</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.AddBinary(Tridion.ContentManager.Templating.Item,Tridion.ContentManager.TcmUri)">
            <summary>
            Publish a binary from a given Multimedia Item.
            </summary>
            <remarks>
            For more AddBinary alternatives, use 
            <c>Engine.PublishingContext.<see cref="T:Tridion.ContentManager.Publishing.Rendering.RenderedItem"/>.AddBinary(...)</c>.
            </remarks>
            <param name="multimediaItem">The multimedia item in the package to publish</param>
            <param name="targetLocation">The location to publish the binary to if the item does not specify.</param>
            <returns>The path of the binary as it was published to</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetObject(Tridion.ContentManager.Templating.Item)">
            <summary>
            Get the Tom.Net tridion representation for a specified package item.
            </summary>
            <remarks><para>This is the prefered way of retrieving Tom.Net Tridion items.
            It supercedes the previous method <seealso cref="M:Tridion.ContentManager.Templating.Engine.GetObject(Tridion.ContentManager.TcmUri)"/> which may result in either an additonal call to the Content Manager
            or returns the last saved item from the <seealso cref="M:Tridion.ContentManager.Session.GetObject(System.String)"/> cache.
            </para>
            <para>
            One advantage is that it simplifies the API usage for dealing with Tom.Net Tridion Items.
            Prior to this overload to get the item involved code such as
            <example> 
               Item componentItem = package.GetByType(ContentType.Component);
               Component component = engine.GetObject(componentItem.GetAsSource().GetValue("ID"));
               // or 
               Component component = engine.GetObject(package.GetValue("Component.ID")) as Component
            </example>
            Now the same result can be achived with 
            <example>
               Item componentItem = package.GetByType(ContentType.Component);
               Component component = engine.GetObject(componentItem) as Component;
            </example>
            </para>
            <para>
            Another capabability offered is that is it eables the retrieval of a non saved / dynamic versions of the item.
            </para>
            </remarks>
            <param name="packageItem">The package item to be retrieved.</param>
            <returns>The Tom.Net tridion object for the specified package item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.GetObjectType(System.Xml.XmlElement)">
            <summary>
            Get the TOM.NET type for a given Tridion XML representation
            </summary>
            <param name="tridionXml">The Tridion XML represenation</param>
            <returns>A Type instance</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Engine.IsInLimitedPreviewMode">
            <summary>
            Gets a value indicating whether the engine is in limited preview mode.
            </summary>
            <value>
            <c>false</c> if <c>RenderMode</c> is Publish and/or a Publishing Target has been specified, otherwise <c>true</c>.
            </value>
            <remarks>
            In limited preview mode we suppress TCDL from the result and put the binaries in the configured preview location.
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Engine.PublishingContext">
            <summary>
            Get the .Net publishing context in which this template is executed.
            </summary>
            <remarks>
            The Publishing Context consists of items in the <c>Tridion.ContentManager.Publishing</c>
            assembly, and serve as context for the current publishing actions.
            In case no PublishingContext is available (in practice, when a Template Building Block 
            is being debugged in the Template Builder), the property-value is null.
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Engine.RenderMode">
            <summary>
            The RenderMode of the current publishing action.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Engine.CompoundTemplateLoopDetector">
            <summary>
            ITemplateInvocationListener that is always registered and checks whether a compound
            template has not been invoked before on a higher level in the stack (meaning you always
            have an infinite loop, because this template must then lead to this template again).
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.ITemplateInvocationListener">
            <summary>
            Classes implemting this interface can register themselves with the Engine to receive notifications 
            of templates being invoked. They can use these notifications to inspect or modify the package while
            it's being constructed.
            </summary>
            <seealso cref="M:Tridion.ContentManager.Templating.Engine.RegisterTemplateInvocationListener(Tridion.ContentManager.Templating.ITemplateInvocationListener)"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ITemplateInvocationListener.TemplateInvoking(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            This method is called by the engine just before it invokes a template.
            </summary>
            <param name="package">The package that will be passed to the template</param>
            <param name="invocation">The template that will be invoked and the parameters that will be passed to it</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ITemplateInvocationListener.TemplateInvoked(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation,System.Exception)">
            <summary>
            This method is called by the engine right after it has invoked a template.
            </summary>
            <param name="package">The package that was passed to the template</param>
            <param name="invocation">The template that was invoked and the parameters that were passed to it</param>
            <param name="exception">In case there was an exception during the invocation, it can be passed
            (or left to null)</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.CompoundTemplateLoopDetector.TemplateInvoking(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            Register the about to be executed template on the stack
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Engine.CompoundTemplateLoopDetector.TemplateInvoked(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation,System.Exception)">
            <summary>
            Unregister the just executed template from the stack (a template may be executed multiple
            times in succession).
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.#ctor(Tridion.ContentManager.Templating.Debugging.DebugSession,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="debugSession">The associated session for this debugging engine</param>
            <param name="compoundTemplateUri">The URI of the (possibly new) compound template to execute</param>
            <param name="compoundTemplateContent">The template to run</param>
            <param name="preview">Whether or not the preview mode should be used</param>
            <param name="userName">The username to create the session under (null means current user)</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.SetItemToRender(System.String)">
            <summary>
            Set the item to render (either this or SetPackageToRender should be called)
            </summary>
            <param name="itemUri">The URI of the item to render</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.SetupDummyPublishingContext">
            <summary>
            Set up the Publishing Context object.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.SetPackageToRender(System.Xml.XmlDocument)">
            <summary>
            Set the item to render (either this or SetItemToRender should be called)
            </summary>
            <param name="packageToRender">The XML-serialized package to render</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.SetPublicationTarget(System.String)">
            <summary>
            Set the publication target to be used in this template execution
            </summary>
            <param name="publicationTargetUri">The publication target URI (null to clear the publication target)</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.StopWritingItems">
            <summary>
            Stops the writing of packages that was previously started by calling
            <c>WritePackagesTo</c>.
            Also no longer writes images from this point on.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.Run">
            <summary>
            Method called from start, that does the actual template execution.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.GetLastException">
            <summary>
            Access to the exception of the template, if execution failed.
            </summary>
            <returns>The templating exception if there is one, or null if there was no exception (yet).</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.GetExecutionStatusXml">
            <summary>
            Get the current execution status (on what invocations were performed) of the template
            execution. Is updated constantly while running.
            </summary>
            <returns>A document with the template invocations of the template execution run, or null
            if there were no invocations so far.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.GetLogMessagesXml(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the logging messages Xml of the currently active session.
            (output may be updated as template runs)
            </summary>
            <param name="templateInvocationId">The template invocation to retrieve messages for (-1 for all invocations)</param>
            <param name="startId">The first message to retrieve (-1 for the first matching messages)</param>
            <param name="maxCount">The maximum amount of messages to retrieve (-1 for all matches)</param>
            <returns>The log messages within the invocations in an XML format (all known invocations are always present
            the messages only those that match the filter)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.GetContextPublicationUri">
            <summary>
            Method that determines the current publication where engine is excecuting within.
            </summary>
            <returns>The Tcm URI of the context publication, or null if thise cannot be determined</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.CheckInitialized">
            <summary>
            Check whether the API-calls of the engine may be used.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.SetupRenderInstruction(Tridion.ContentManager.Publishing.RenderInstruction)">
            <summary>
            Implementation of SetupRenderInstruction.
            </summary>
            <param name="renderInstruction">The render instruction to process</param>
            <returns>The publication target used for this publishing action</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.AddBinary(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri,System.Byte[],System.String)">
            <summary>
            Publish a binary from a byte-array with a given filename.
            </summary>
            <param name="componentUri">The multimedia component this item refers to</param>
            <param name="templateUri">The template in whose context this PublishBinary call is executed</param>
            <param name="targetLocation">The location to publish the binary to</param>
            <param name="data">The binary data to publish</param>
            <param name="fileName">The filename to publish the file under</param>
            <returns>The path of the binary as it was published to</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.AddBinary(Tridion.ContentManager.Templating.Item,Tridion.ContentManager.TcmUri)">
            <summary>
            Publish a binary from a given Multimedia Item.
            </summary>
            <param name="multimediaItem">The multimedia item in the package to publish</param>
            <param name="targetLocation">The location to publish the binary to if the item does not specify.</param>
            <returns>
            The path of the binary as it was published to
            </returns>
            <remarks>
            For more AddBinary alternatives, use
            <c>Engine.PublishingContext.<see cref="T:Tridion.ContentManager.Publishing.Rendering.RenderedItem"/>.AddBinary(...)</c>.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.SerializeXml(System.Xml.XmlDocument)">
            <summary>
            Serialize an XML document to a string.
            </summary>
            <param name="document">The document to serialize</param>
            <returns>The document as a string</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.DebuggingLogger">
            <summary>
            Access for the debugging logger, in case still active
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.DebuggingEngine.RenderMode">
            <summary>
            Property to get the RenderMode of the current publication action
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.DebugSession">
            <summary>
            This class acts an intermediate between Debugger and DebugEngine, persisting the state of a
            debug session (and giving access when it is still running.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.#ctor(System.String,System.String,System.String,System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.Diagnostics.TraceEventType)">
            <summary>
            Create a new debugger object.
            </summary>
            <remarks>
            Every caller of this method should ensure to also call the Close-method with 
            the generated session id, to ensure proper cleanup of sessions.
            </remarks>
            <param name="sessionId">A unique identifier for the debugging session</param>
            <param name="compoundTemplateUri">The URI of the (possibly new) compound template to execute</param>
            <param name="compoundTemplateContent">The compound template to execute</param>
            <param name="itemUri">The page or component to execute the template on</param>
            <param name="packageContents">The existing serialized package to execute the template on</param>
            <param name="preview">Where the rendering should occur as preview or render</param>
            <param name="userName">The (optional) user the template execution should occur as. If not set,
            the username is taken from the context</param>
            <param name="publicationTargetUri">The (optional) publication target that the template would be executed for</param>
            <param name="logTridionClasses">Whether or not to include standard classes in the output</param>
            <param name="logLevel">The level of logging to include</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.#ctor(System.String)">
            <summary>
            Create a new debugger object, based on an existing persistent session (so cannot
            be started).
            </summary>
            <param name="sessionId">The id of this session</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.SetPreviewLocations(System.String,System.String)">
            <summary>
            Set the locations of previewed binaries
            </summary>
            <param name="previewDirectory">The directory to store binaries</param>
            <param name="previewUrl">The base URL for stored preview items</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetSessionDirectory">
            <summary>
            Get the working directory of this specific debug session.
            </summary>
            <returns>The working directory of this debug session.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetPreviewDirectory">
            <summary>
            Get the preview directory of this specific debug session.
            To be used in combination with GetPreviewUrl (these point at the same directories).
            </summary>
            <returns>The preview directory of this debug session.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetPreviewUrl">
            <summary>
            Get the preview URL of this specific debug session.
            To be used in combination with GetPreviewDirectory (these point at the same directories).
            </summary>
            <returns>The preview URL of this debug session.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.Start">
            <summary>
            Start the template execution (in a new thread)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.Run">
            <summary>
            Method called from start, that does the actual template execution.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.Stop">
            <summary>
            Hard-stop the debugging process.
            </summary>
            <remarks>
            This should only be called in exceptional circumstances, normally
            the templating will stop by itself. An attempt is made to stop
            the thread, as well as output to the package directory.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.IsRunning">
            <summary>
            Check whether a templating action is still running, after start has been called.
            </summary>
            <returns>Whether or not the templating execution is currently still active.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetLastException">
            <summary>
            Get the exception thrown from templating, if there was one.
            </summary>
            <remarks>
            This is the only method that can be used to determine whether
            an error occurred.
            </remarks>
            <returns>The string representation of the exception that stopped the template execution, or null in case there
            was no exception (could be that exception occurs later)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetExecutionStatusXml">
            <summary>
            Get the current execution status XML document as a string
            </summary>
            <returns>Null in case there have been no invocations yet. Otherwise
            contains information on all the invocations that have been active so far.
            An invocation is only complete if it has a duration.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetPackageXml(System.String)">
            <summary>
            Get the XML contents of a package.
            </summary>
            <param name="name">The name of the package to retrieve. The names are present in the 
            GetExecutionStatusXml document</param>
            <returns>The package xml</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case no package with such a name exists</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetPackageItemXml(System.String)">
            <summary>
            Get the XML contents of a package item.
            </summary>
            <param name="name">The unique name of the item to retrieve. The names are present in the 
            GetPackageXml documents</param>
            <returns>The item data within an xml element</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case no item with such a name exists</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetLogMessagesXml(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the logging messages Xml of the currently active session.
            (output may be updated as template runs)
            </summary>
            <param name="templateInvocationId">The template invocation to retrieve messages for (-1 for all invocations)</param>
            <param name="startId">The first message to retrieve (-1 for the first matching messages)</param>
            <param name="maxCount">The maximum amount of messages to retrieve (-1 for all matches)</param>
            <returns>The log messages within the invocations in an XML format (all known invocations are always present
            the messages only those that match the filter)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.FileExists(System.String)">
            <summary>
            Check whether a file exists
            </summary>
            <remarks>Only needs to check for the base name, even if files with prefixes
            may exist.</remarks>
            <param name="name">The name of the file (within the session's working directory</param>
            <returns>Whether or not the file exists</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.ReadFile(System.String)">
            <summary>
            Utitility method for to read a file into a string
            The last file matching the pattern used in reading/ writing files is used.
            </summary>
            <remarks>
            The encoding of these files should always be UTF-8
            </remarks>
            <param name="name">The name of the debugging artifact to read</param>
            <returns>The contents of the item as a string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.WriteFile(System.String,System.String)">
            <summary>
            Write a string to disk, in the session's working directory, in encoding UTF-8.
            In case of duplicate filenames, the name is prefixed with incrementing number_.
            </summary>
            <param name="name">The name of the file to read</param>
            <param name="contents">The contents of the file</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.FindFile(System.String,System.String,System.Boolean)">
            <summary>
            Find a file-name using the incrementing naming scheme. To ensure files can be
            written as they are read, each overwrite of a file is done under another name.
            </summary>
            <param name="directory">The directory the file should be written to</param>
            <param name="name">The base-name of the file to to find</param>
            <param name="shouldExist">Whether an existing file should be found, or a new unique
            path should be created</param>
            <returns>The path found, or null when no path could be found (only if shouldExist
            is true).</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.FindFiles(System.String,System.String,System.Boolean)">
            <summary>
            Helper method to implement FindFile(s)
            </summary>
            <remarks> This code assumes there is only one thread actively writing files.</remarks>
            <param name="directory">The directory to look in</param>
            <param name="name">The name to look for</param>
            <param name="shouldExist">Whether or not the last file included in the list
            should exist or not</param>
            <returns>A list of files on the filesystem matching the pattern, including one
            file that does not exist yet (if shouldExist is true)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebugSession.GetExceptionAsString(System.Exception)">
            <summary>
            Convert an exception to a string representation.
            </summary>
            <param name="exception">The exception</param>
            <returns>A string representation of the exception (including stacktraces and inner exceptions)</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.DebugSession.DebuggingLogger">
            <summary>
            Access for the debugging logger, in case still active
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.DebugSession.SessionId">
            <summary>
            Accessor for the current session identifier.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate">
            <summary>
            Class to represent a compound template that is not in the CMS.
            </summary>
            <remarks>
            This code is a total hack in that it is based on what was already available in unittesting.
            Depends on implementation of Template class stays as it is (especially the constructor), and
            that the rest of templating always accesses compound Template objects through the wrapper.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.GetManagementRights">
            <summary>
            Get the type of security management rights associated with the item type.
            </summary>
            <returns>A <see cref="T:Tridion.ContentManager.Security.Rights"/> value associated with the item type.</returns>        
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.#ctor(System.String,System.String,Tridion.ContentManager.Session)">
            <summary>
            Constructor
            </summary>
            <param name="compoundTemplateUri">The URI of the (possibly new) compound template to execute</param>
            <param name="wrappedTemplate">The content of the in-memory template</param>
            <param name="session">The session this object is created in</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.GetApprovalStatus">
            <summary>
            Returns the Approval Status of the Template.
            </summary>
            <returns>
            Returns <see cref="P:Tridion.ContentManager.CommunicationManagement.Template.ApprovalStatus"/> Object.
            </returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.WrappedTemplate">
            <summary>
            Accessor for the wrapped template
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper">
            <summary>
            Template wrapper implementation with dummy implementations for all methods
            that are called on compound templates.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplateWrapper">
            <summary>
            Representation of a Template.
            Essentially a wrapper around a Tridion.ContentManager.CommunicationManagement.Template.
            Here mostly for backwards compatibility for unittests.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.#ctor">
            <summary>
            Constructor for use from UnitTests.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.#ctor(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Constructor to fully initialize a Template object.
            </summary>
            <param name="template">The template to represent</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.Create(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Create a TemplateWrapper for a given template object
            </summary>
            <param name="template">The template to wrap</param>
            <returns>A wrapped template</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.ConstructWrappedTemplate(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Method to override in unittesting, that constructs a wrapped template.
            </summary>
            <param name="template">The template to wrap</param>
            <returns>A wrapped template</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.GetValue(System.String)">
            <summary>
            Gets a value from the (metadata of) the template
            </summary>
            <param name="name">the name of the value to retrieve</param>
            <returns>the string value of the requested name from this template or null of the 
            template doesn't have a value for the requested name</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.GetMetaValue(Tridion.ContentManager.ContentManagement.RepositoryLocalObject,System.String)">
            <summary>
            Gets a value from the metadata of a repositoryObject
            </summary>
            <param name="repositoryObject">The object with meta data</param>
            <param name="name">The name of the meta-data field to retrieve (must be a top-level field)</param>
            <returns>The string-representation of the meta-data value, or null if the meta-data could not be found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.HasBinaryContent">
            <summary>
            Returns true when this template is based on binary content and false when it is based on textual content.
            You can call <c>GetMimeType</c> to determine more details about the contents of the template.
            </summary>
            <returns>true when this template is based on binary content and false when it is based on textual content</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateWrapper.GetMimeType">
            <summary>
            Return the MIME-type of this template. Note that currently this will actually return the namespace URI
            of the template if this template is based on a (non-multimedia) component.
            </summary>
            <returns>The MIME-type of this template, or null if it could not be determined.</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateWrapper.Id">
            <summary>
            Access to the id of the template
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateWrapper.Title">
            <summary>
            Access to the name of the template
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateWrapper.Content">
            <summary>
            Get the textual content of the template as a string
            </summary>
            <returns>The textual content of the template.</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateWrapper.BinaryContent">
            <summary>
            Get the binary content of the template as a byte array
            </summary>
            <returns>The binary content of the template or an exception.
            Check <see cref="M:Tridion.ContentManager.Templating.TemplateWrapper.HasBinaryContent"/> before calling./&gt;.</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateWrapper.ParameterSchema">
            <summary>
            The parameter schema of the template.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateWrapper.InDebugMode">
            <summary>
            Is this template loaded from the CMS or being debugged
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="compoundTemplateUri">The URI of the (possibly new) compound template to execute</param>
            <param name="content">The template content to represent</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper.GetMimeType">
            <summary>
            Override of the Mime-type, currently fixed to the default.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper.Id">
            <summary>
            Dummy implementation of Id (the compound template need not be stored yet)
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper.Title">
            <summary>
            Dummy implementation of Title (the compound template need not be stored yet)
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper.Content">
            <summary>
            Accessor for the template content
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper.ParameterSchema">
            <summary>
            Dummy implementation of parameter schema (the compound template is assumed not
            to have parameters or a schema)
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.InMemoryCompoundTemplate.InMemoryCompoundTemplateWrapper.InDebugMode">
            <summary>
            This property is here specifically for this class, to indicate this is a special
            wrapped template.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.DebuggingLogger">
            <summary>
            Debugging logger, a special class to capture the logging to a file.
            </summary>
            <remarks>
            This class's implementation is closely tied to the TemplatingLogger class.
            
            The general structure of the document is:
            <logging>
            	<invocation templateUri="tcm:?-?-?" invocationId="1">
            		<!-- Possibly nested invocation -->
            		<invocation templateUri="tcm:?-?-?" invocationId="2">
            			<log id="1" type="Verbose">Some message</log>
            		</invocation>
            		<log id="2" type="Warning">Some message</log>
            	</invocation>
            	<invocation templateUri="tcm:?-?-?" invocationId="1">
            		<log id="3" type="Error">Some message</log>
            	</invocation>
            </logging>
            Where invocation ids are numbered as the PackageDumper does, and log-messages
            are numbered in sequence.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.#ctor(Tridion.ContentManager.Templating.Engine,System.String)">
            <summary>
            Creates a new log dumper for the given engine. It will register itself with
            the engine to listen in on template invocations, and on the logger to listen in on logging
            actions.
            </summary>
            <param name="engine">The engine to listen in on.</param>
            <param name="logFileDirectory">The directory to which log-files will be written.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.#ctor(System.String)">
            <summary>
            Reconstruct a logging document based on its written out files
            </summary>
            <param name="logfileDirectory"></param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.Log(System.Diagnostics.TraceEventType,System.String,System.Type,System.Exception)">
            <summary>
            Main access method (not in a separate interface to keep design simple), as used 
            from TemplatingLogger.
            </summary>
            <param name="severity">The severity of this message</param>
            <param name="message">The message content</param>
            <param name="typeToLogFor">The class that executes the logging message</param>
            <param name="exception">The possible exception associated with this message</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.ShouldLogMessage(System.Diagnostics.TraceEventType,System.Type)">
            <summary>
            Determine whether the message about to be logged should be logged
            </summary>
            <param name="severity">The severity of the current message</param>
            <param name="typeToLogFor">The type that initiated this logging call</param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.WritePartialLogFile">
            <summary>
            Write out the current log to a file, and then reset the log.
            </summary>
            <remarks>
            After being called, GetLogMessagesXml is no longer reliable.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.GetLogMessagesXml(System.Int32,System.Int32,System.Int32)">
            <summary>
            Access method to get the logging messages as a document, possibly filtered.
            All known invocations are always present in the document, it is only the
            messages that are present or not.
            </summary>
            <remarks>
            The filter parameters mentioned below may be combined.
            </remarks>
            <param name="invocation">Filter on what invocation (and subinvocations) to get messages
            on (-1) for all</param>
            <param name="startId">Filter on what first message should be included (-1 for all
            messages)</param>
            <param name="maxCount">Filter on the maximum amount of messages to return (-1 for all
            matching messages)</param>
            <returns>An xml document string with the matching messages</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.GetLogMessagesXml(System.Xml.XmlDocument,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Helper for GetLogMessages...Xml
            </summary>
            <seealso cref="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.GetLogMessagesXml(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.WriteLogElements(System.Xml.XmlWriter,System.Xml.XmlElement,System.Int32,System.Int32,System.Int32@,System.Boolean)">
            <summary>
            Recursive method to write (a selection of) the log messages
            in a document to stream.
            </summary>
            <param name="writer">The writer to write the constructed XML document to</param>
            <param name="currentElement">The current element being processed</param>
            <param name="invocationToGet">Filter on what invocation (and subinvocations) to get messages
            on (-1) for all</param>
            <param name="startId">Filter on what first message should be included (-1 for all
            messages)</param>
            <param name="amountToRetrieve">The number of log messages to collect (-1 for unlimited). If
            not unlimited, is updated once an extra message is added.</param>
            <param name="removeEncounteredLogMessages">Whether or not to remove serialized messages from
            the document (to only serialize them once)</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.Dispose">
            <summary>
            Disposes this LogDumper (by unregistering it)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.TemplateInvoking(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            On template invoking, register the template invocation in the log document.
            </summary>
            <param name="package">The context package</param>
            <param name="invocation">The invocation about to be started</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.TemplateInvoked(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.TemplateInvocation,System.Exception)">
            <summary>
            On template invoked, move up one level in the template invocation stack, and write
            the logging collected so far to disk.
            </summary>
            <param name="package">The context package</param>
            <param name="invocation">The current invocation (ignored in this method)</param>
            <param name="exception">A possible exception (currently not used)</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.LogTridionClasses">
            <summary>
            Accessor for whether messages in classes of the Tridion.ContentManager.... namespace
            should be logged.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.DebuggingLogger.LogLevel">
            <summary>
            Accessor for the log-level (what messages are included).
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.PackageDumper">
            <summary>
            A package dumper that can be registered with an Engine to write packages to disk.
            When you create an instance of this class it will immediately create an Invocations.xml
            file. This file will continue to be updated as templates are being executed, so it might
            contain invalid XML if the engine is not done executing all templates.
            </summary>
            <remarks>
            This class is used by the publish <c>WritePackagesTo</c> and <c>StopWritingPackages</c>
            methods of the <c>Engine</c> class and the <c>IEngine</c> COM interface.
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Debugging.PackageDumper._writePrePackages">
            <summary>
            When this field is set to <c>true</c> the dumper will write both a pre- and
            a post-package for each invoked template. If the field is set to <c>false</c>
            the dumper will write a post-package for each invoked template and a single
            "start package" (pre_0.xml) marking the final contents of the package.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.#ctor(Tridion.ContentManager.Templating.Engine,System.String)">
            <summary>
            Creates a new package dumper for the given engine. The package dumper will register itself with
            the engine to listen in on template invocations. For each template invocation it will write a
            {package index}.xml to the directory you specify.
            </summary>
            <param name="engine">The engine to listen in on.</param>
            <param name="directory">The directory to which the packages will be written.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.Dispose">
            <summary>
            Disposes of the resources used by this PackageDumper. This method should be called by client
            code that creates and uses the PackageDumper. If this doesn't happen it will also be called by
            the .NET framework when it has identified the PackageDumper as not being in use anymore.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.Finalize">
            <summary>
            Ensure package dumper is always deregistered from the engine before it is garbage
            collected (although these objects will always be collected in pairs?)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.WriteInvocationsToDisk">
            <summary>
            Write the invocations document to disk
            </summary>
            <remarks>The naming convention of DebugSession is used (being
            that existing files are not overwritten, and that the file only gets its
            resulting name after writing is complete).</remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.SetInvocationFailed(System.Xml.XmlNode)">
            <summary>
            Utility method to set Failed=true attribute on an invocation node and all its
            ancestores.
            </summary>
            <param name="invocationElement">The node</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.Push(Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            Pushes the given template invocation onto the stack of invocations, with a unique identifier.
            After pushing the invocation, you can get its stack entry (and from that its unique identifier)
            by calling GetStackEntryFor(invocation).
            </summary>
            <param name="invocation">the invocation to push onto the stack.</param>
            <returns>the StackEntry that was pushed onto the top of the stack.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.Pop(Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            Pops the top entry from the stack of invocations, if it matches the given invocation.
            </summary>
            <param name="invocation">The invocation to pop from the stack.</param>
            <returns>The StackEntry that was popped from the top of the stack.</returns>
            <exception cref="T:Tridion.TridionArgumentException">Thrown when the invocation specified is 
            not at the top of the stack</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.GetCallstack">
            <summary>
            Returns a string representing the current stack of template invocations. The string is built from
            concatenating the unique identification of each invocation, separated by a dot. So if you have
            three nested templates, you'll get back "1.2.3." as the call stack for the innermost template.
            If you add a sibling invocation after two, its call stack will be "1.4".
            </summary>
            <returns>The call stack for the current template invocation.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.GetStackEntryFor(Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            Returns the stack entry for the given invocation.
            </summary>
            <param name="invocation">The invocation for which to return the stack entry.</param>
            <returns>The stack entry for the given invocation.</returns>
            <exception cref="T:Tridion.TridionArgumentException">Thrown when the given invocation doesn't 
            exist in the call stack.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Debugging.PackageDumper.GetPackageFilename(Tridion.ContentManager.Templating.TemplateInvocation)">
            <summary>
            Returns the filename to use for storing the package after the given invocation. When the invocation
            is <c>null</c>, it will return the filename for the initial package.
            </summary>
            <param name="invocation">The invocation for which to return the filename for storing the 
            package, or null to return the filename for the initial package.</param>
            <returns>The filename to use for storing the package after the given invocation.</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.PackageDumper.WriteItemsContentSeparately">
            <summary>
            Accessor to whether items are placed in separate files
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.PackageDumper.WritePrePackages">
            <summary>
            Get/ set whether prepackages are written for each invocation.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Debugging.PackageDumper.InvocationDocument">
            <summary>
            Access the invocation document in its current state.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Debugging.PackageDumper.StackEntry">
            <summary>
            Internal structure used to keep track of nested template invocations.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Expression.BuiltInFunctions">
            <summary>
            Functions available to expression evaluation; for example, in a Dreamweaver template or by directly calling
            <see cref="M:Tridion.ContentManager.Templating.Package.EvaluateExpression(System.String)"/>
            </summary>
            <remarks>
            This is a sealed class, meaning that you can't inherit from it.
            Inheriting from this class would result in "non-modular" extensions, because multiple of such extensions can't combined.
            If you want to "override" built-in functions, you can create your own class with a method with the same name as the built-in function
            in it and then ensure that your class is configured before the BuiltInFunctions class.
            In this manner, your method effectively hides the built-in function. If needed, the implementation of your method can call the original
            built-in function by creating a BuiltInFunctions instance.
            </remarks>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Expression.IFunctionSource">
            <summary>
            Implement <c>IFunctionSource</c> to mark a class as containing methods that can be called from a template; for example, a Dreamweaver template.
            Such methods must be marked with <see cref="T:Tridion.ContentManager.Templating.Expression.TemplateCallableAttribute"/>
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.IFunctionSource.Initialize(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Initializes the function source with context data.
            </summary>
            <param name="engine">The engine.</param>
            <param name="package">The package.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.Tridion#ContentManager#Templating#Expression#IFunctionSource#Initialize(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Initializes the function source with context data.
            </summary>
            <param name="engine">The engine.</param>
            <param name="package">The package.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.#ctor(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Initializes a new instance of the <see cref="T:Tridion.ContentManager.Templating.Expression.BuiltInFunctions"/> class.
            </summary>
            <param name="engine">The engine.</param>
            <param name="package">The package.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Tridion.ContentManager.Templating.Expression.BuiltInFunctions"/> class.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.Initialize(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Initializes the function source with context data.
            </summary>
            <param name="engine">The engine.</param>
            <param name="package">The package.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.StringLength(System.Object)">
            <summary>
            Determines the length of the string value of an object.
            </summary>
            <param name="obj">The object to get the string length from (done on the ToString() result)</param>
            <returns>The length of the string value of an object, or 0 if that could not be determined.</returns>	
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.GetBinaryInfo">
            <summary>
            Gets the binary info.
            </summary>
            <returns>Information about binary content and multimedia type of component from package.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.GetComponentTitle(System.String)">
            <summary>
            Gets the Title of the Component.
            </summary>
            <param name="componentUri">The <see cref="T:Tridion.ContentManager.TcmUri"/> or WebDavUrl of the component.</param>
            <returns>
            The title of the input component.
            </returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.GetComponentMimeType(System.String)">
            <summary>
            Gets the multimedia type of the Multimedia Component.
            </summary>
            <param name="componentUri">The <see cref="T:Tridion.ContentManager.TcmUri"/> or WebDavUrl of the component.</param>
            <returns>
            Returns title of the multimedia type of the input component.
            </returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.GetFieldMetadata(System.String)">
            <summary>
            Gets the field's metadata.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <returns>Field's metadata if any; empty string otherwise.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.GetFieldMetadata(System.String,System.Boolean)">
            <summary>
            Gets the field's metadata.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="isMetaDataField">if set to <c>true</c> [is metadata field].</param>
            <returns>Field's metadata if any; empty string otherwise.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.RenderComponentField(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Locates the value of a field of the context component expressed by [fieldExpression].
            The resulting value is embedded in a tcdl:ComponentField tag that stores the fieldExpression in an
            attribute, as well as the index of the value in case of multi-values (starting at index 1).
            These tags will be removed by the CleanupTemplate.
            <para>
            This method has been deprecated. Please use <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)"/>  and <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker"/> instead.
            </para>
            </summary>
            <param name="fieldExpression">Reference to a field relative to the context component. For example Fields.MyEmbeddedSchema.MyField</param>
            <param name="fieldIndex">Index of this value for multi-valued fields starting at 1. Single-value fields simply use 1</param>        
            <param name="htmlEncodeResult">if set to <c>true</c> [HTML encode result].</param>
            <param name="resolveHtmlAsRTFContent">if set to <c>true</c> [resolve HTML as RTF content].</param>
            <returns>
            The value of a field on the context component surrounded with tcdl:ComponentField
            </returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">When there is no context component or the expression cannot be resolved on it</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.RenderComponentField(System.String,System.Int32)">
            <summary>
            Locates the value of a field of the context component expressed by [fieldExpression].
            The resulting value is embedded in a tcdl:ComponentField tag that stores the fieldExpression in an
            attribute, as well as the index of the value in case of multi-values (starting at index 1).
            These tags will be removed by the CleanupTemplate.
            <para>
            This method has been deprecated. Please use <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)"/>  and <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker"/> instead.
            </para>
            </summary>
            <param name="fieldExpression">Reference to a field relative to the context component. For example Fields.MyEmbeddedSchema.MyField</param>
            <param name="fieldIndex">Index of this value for multi-valued fields starting at 1. Single-value fields simply use 1</param>
            <returns>
            The value of a field on the context component surrounded with tcdl:ComponentField
            </returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">When there is no context component or the expression cannot be resolved on it</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.RenderComponentField(System.String,System.Int32,System.String)">
            <summary>
            Locates the value of a field of the context component expressed by [fieldExpression].
            The resulting value is embedded in a tcdl:ComponentField tag that stores the fieldExpression in an
            attribute, as well as the index of the value in case of multi-values (starting at index 1).
            These tags will be removed by the CleanupTemplate.
            <para>
            This method has been deprecated. Please use <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)"/>  and <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker"/> instead.
            </para>
            </summary>
            <param name="fieldExpression">Reference to a field relative to the context component. For example Fields.MyEmbeddedSchema.MyField</param>
            <param name="fieldIndex">Index of this value for multi-valued fields starting at 1. Single-value fields simply use 1</param>
            <param name="value">Instead of looking up the field value, passthrough a value, eg IMG/A tags</param>
            <returns>
            The value of a field on the context component surrounded with tcdl:ComponentField
            </returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">When there is no context component or the expression cannot be resolved on it</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)">
            <summary>
            Locates the value of a field of the context component/page expressed by <paramref name="fieldExpression"/>
            and outputs tcdl:Field tag that stores the XPath of the field and <see cref="T:Tridion.ContentManager.TcmUri"/> of the Item.
            <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldEndMarker"/> must be called to output the end tag for tcdl:Field.
            These tags will be removed by the <see cref="T:Tridion.ContentManager.Templating.Templates.CleanupTemplate"/>.
            </summary>
            <param name="fieldExpression">Reference to a field relative to the context component/page. For example Fields.MyEmbeddedSchema.MyField.</param>
            <returns>
            Returns tcdl:Field start tag with XPath of the field and <see cref="T:Tridion.ContentManager.TcmUri"/> of the item as attributes.
            </returns>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldEndMarker"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueEndMarker"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldEndMarker">
            <summary>
            Outputs tcdl:Field end tag. 
            This function must be called after <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)"/>.
            These tags will be removed by the <see cref="T:Tridion.ContentManager.Templating.Templates.CleanupTemplate"/>.
            </summary>
            <returns>Returns tcdl:Field end tag.</returns>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueEndMarker"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker">
            <summary>
            Outputs tcdl:FieldValue tag that stores the index of the field value.
            <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueEndMarker"/> must be called to output the end tag for tcdl:Field.
            These tags will be removed by the <see cref="T:Tridion.ContentManager.Templating.Templates.CleanupTemplate"/>.
            </summary>
            <returns>Returns tcdl:FieldValue start tag with index of the field value as attribute.</returns>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldEndMarker"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueEndMarker"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker(System.Int32)">
            <summary>
            Outputs tcdl:FieldValue tag that stores the index of the field value.
            <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueEndMarker"/>  must be called to output the end tag for tcdl:Field.
            These tags will be removed by the <see cref="T:Tridion.ContentManager.Templating.Templates.CleanupTemplate"/>.
            </summary>
            <param name="fieldIndex">Index of this value for multi-valued fields starting at 0. Single-value fields simply use 0.</param>
            <returns>Returns tcdl:FieldValue start tag with index of the field value as attribute.</returns>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldStartMarker(System.String)"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldEndMarker"/>
            <seealso cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueEndMarker">
            <summary>
            Outputs tcdl:FieldValue end tag. 
            This function must be called after <see cref="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.FieldValueStartMarker"/>.
            These tags will be removed by the <see cref="T:Tridion.ContentManager.Templating.Templates.CleanupTemplate"/>.
            </summary>
            <returns>Returns tcdl:FieldValue end tag.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.GetFieldValue(System.String,System.Int32)">
            <summary>
            Locates the value of a field on the context expressed by [fieldExpression].
            </summary>
            <param name="fieldExpression">Reference to a field relative to the context. For example Fields.MyEmbeddedSchema.MyField</param>
            <param name="fieldIndex">Index of this value for multi-valued fields starting at 0. Single-value fields simply use 0</param>        
            <returns>
            The value of a field on the context
            </returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">When the expression cannot be resolved</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.GetFieldValue(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Locates the value of a field on the context expressed by [fieldExpression].
            </summary>
            <param name="fieldExpression">Reference to a field relative to the context. For example Fields.MyEmbeddedSchema.MyField</param>
            <param name="fieldIndex">Index of this value for multi-valued fields starting at 0. Single-value fields simply use 0</param>        
            <param name="htmlEncodeResult">if set to <c>true</c> [HTML encode result].</param>
            <param name="resolveHtmlAsRTFContent">if set to <c>true</c> [resolve HTML as RTF content].</param>
            <returns>
            The value of a field on the context
            </returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">When the expression cannot be resolved</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.RenderComponentPresentation">
            <summary>
            Render a component presentation in the current package context.
            Prerequisites: The package must contain enough information to perform the rendering
             - If a componentUri is not specified, a Component must be present in the package
            (the top-most one is used).
             - If a templateUri is not specified, a Component must be present in the package
            (the top-most one is used) with a preferred Template-URI property on it.
            </summary>
            <returns>The result of rendering the component presentation (an exception is thrown in case of a failure)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.RenderComponentPresentation(System.String,System.String)">
            <summary>
            Render a component presentation in the current package context.
            Prerequisites: The package must contain enough information to perform the rendering
             - If a componentUri is not specified, a Component must be present in the package
            (the top-most one is used).
             - If a templateUri is not specified, a Component must be present in the package
            (the top-most one is used) with a preferred Template-URI property on it.
            </summary>
            <param name="componentUri">The component to render (if null, is determined from the package context)</param>
            <param name="templateUri">The template to use in rendering (if null, is determined from the package context)</param>
            <returns>The result of rendering the component presentation (an exception is thrown in case of a failure)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.SetRenderContextVariable(System.Object,System.Object)">
            <summary>
            Adds a variable to the render context to enable passing information
            between renders; eg, between a page template and component templates.
            If the variable already exists, it is overwritten.
            </summary>
            <param name="name">Variable name.</param>
            <param name="value">Variable value.</param>
            <returns>Empty string.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.CollectionLength(System.String)">
            <summary>
            Determines the length of the collection.
            </summary>
            <param name="expression">The collection expression to get the length from</param>
            <returns>The length of the collection or 0 if that could not be determined</returns>	
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.BuiltInFunctions.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">
            </exception>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Expression.TemplateCallableAttribute">
            <summary>
            Defines a method on a class that implements <see cref="T:Tridion.ContentManager.Templating.Expression.IFunctionSource"/> as callable from a template; for example, a Dreamweaver design.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.FieldSource">
            <summary>
            A FieldSource is a special type of source, representing a full
            field definition. Unlike a FieldValueSource, you can explicitly
            request the name and the values of a field-source, but the source
            itself does not represent that. This class is usually only created
            when 'Fields' are requested explicitly in a source.
            </summary>
            <remarks>
            Extends FieldValueSource for two reasons:
            - So that it is recognized whereever a FieldValueSource is recognized (casting objects).
            - To be able to use FieldValueSource.CreateSourcesForItemField.
            </remarks>
        </member>
        <member name="T:Tridion.ContentManager.Templating.FieldValueSource">
            <summary>
            Internal class to represent:
             - An item field value, either for a list of fields (the usual case) or a single field.
             - An ISource wrapper around such field values (that is also the mechanism to be used externally),
            that can give access to the atomic values through GetValue, or the embedded field structures through GetSources.
            
            This class is meant to be internal, use the ISource access instead.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.#ctor(Tridion.ContentManager.TcmUri,Tridion.ContentManager.ContentManagement.Fields.ItemFields,System.String)">
            <summary>
            General constructor
            </summary>
            <param name="itemUri">The URI of the tridion item this field is part of</param>
            <param name="fields">The field to represent</param>
            <param name="sourcePath">The source-path to the field to represent</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.GetValue(System.String)">
            <summary>
            Determine the string value for a source.
            </summary>
            <param name="fullyQualifiedName">The name to get the source for</param>
            <returns>The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.GetSources(System.String)">
            <summary>
            Retrieve the (list of) subsource(s) of a source. The returned subsource(s)
            can be used again to drill down the expression further.
            
            For example, if calling GetValue("Component.Schema.ID") on a source
            would return a value, calling
            	GetSources("Component.Schema")[0].GetValue("ID")
            would result in the same.
            </summary>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of subsources that match the partially qualified name. Most implementations
            of this method will not return all possible matches, but just the list of sources of the first
            match found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.GetContentType">
            <summary>
            Return the content type of the field represented here
            </summary>
            <returns>An indication this is a field, but no further detail</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.CreateFieldSourceList">
            <summary>
            In certain cases, a FieldValueSource is used to iterate over all
            fields at a certain level. This method constructs the source as a list
            of sources (instead of a single FieldValueSource) to accomplish this.
            </summary>
            <returns>Null in case this FieldValueSource does not represent itemfield*s*,
            otherwise a list with one source per field at this level.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.GetSources(Tridion.ContentManager.ContentManagement.Fields.ItemFields,System.String,System.String)">
            <summary>
            Utility method for ISource.GetSources implementation.
            </summary>
            <remarks>
            Get all sources for the path relative to the current field.
            Recursive method.
            </remarks>
            <param name="itemFields">The fields currently evaluated</param>
            <param name="partiallyQualifiedName">The path to resolve relative to the fields</param>
            <param name="currentSourcePath">The path to the fields parameter</param>
            <returns>The matching sources for this field</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.CreateSourcesForItemField(Tridion.ContentManager.ContentManagement.Fields.ItemField,System.String,System.String,System.Int32)">
            <summary>
            Create a source representation 
            </summary>
            <param name="itemField">The tridion field to create the representation for</param>
            <param name="currentSourcePath">The source path from the Tridion item to this field</param>
            <param name="subQualifiedName">The part of the path not yet resolved</param>
            <param name="includeIndex">In case the current field is multi-value, there can be a selector
            of a specific field</param>
            <returns>A list of sources representing the item field.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.GetSourcesEmbeddedSchemaField(Tridion.ContentManager.ContentManagement.Fields.EmbeddedSchemaField,System.Int32,System.String,System.String)">
            <summary>
            GetSources for an embedded schema field
            </summary>
            <param name="embeddedField">The field to process (which can be multivalue)</param>
            <param name="includeIndex">What item of multi-value fields to include (-1 for all)</param>
            <param name="partiallyQualifiedName">The source-path to evaluate relative to the embedded field</param>
            <param name="currentSourcePath">The source-path to the embedded field</param>
            <returns>The matching sources for this field</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.GetSourcesBasicField(Tridion.ContentManager.ContentManagement.Fields.ItemField,System.Int32,System.String)">
            <summary>
            GetSources for simple (multi-)value field
            </summary>
            <param name="basicField">The field to match (can be multi-value)</param>
            <param name="includeIndex">What item of multi-value fields to include (-1 for all)</param>
            <param name="subQualifiedName">The qualified sub-path to resolve further, only supposed
            to be "" or "ContentType" currently</param>
            <returns>The matching sources found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldValueSource.ResolveIndexFromName(System.String@)">
            <summary>
            Source name expression utility function, to strip an index of an input name.
            If the input is 
            	foo.bar[2]
            the input is changed to 'foo.bar' and 2 is returned.
            This method only works for an index specified at the end of an expression
            </summary>
            <param name="qualifiedName">The input to process</param>
            <returns>The index specified, or -1 if no index is specified.
            As a side effect, if an index is found it is stripped from the input.</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.FieldValueSource.SourcePath">
            <summary>
            The path from Tridion item to *this* field.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.FieldValueSource.ItemUri">
            <summary>
            The id of the item represented.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldSource.#ctor(Tridion.ContentManager.TcmUri,Tridion.ContentManager.ContentManagement.Fields.ItemField,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="itemUri">The item of the Tridion item this field belongs to</param>
            <param name="itemField">The item field to represent</param>
            <param name="sourcePath">The path to this field</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldSource.GetValue(System.String)">
            <summary>
            Determine the string value for a source.
            </summary>
            <param name="fullyQualifiedName">The name to get the source for</param>
            <returns>The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldSource.GetSources(System.String)">
            <summary>
            Retrieve the (list of) subsource(s) of a source. The returned subsource(s)
            can be used again to drill down the expression further.
            
            For example, if calling GetValue("Component.Schema.ID") on a source
            would return a value, calling
            	GetSources("Component.Schema")[0].GetValue("ID")
            would result in the same.
            </summary>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of subsources that match the partially qualified name. Most implementations
            of this method will not return all possible matches, but just the list of sources of the first
            match found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.FieldSource.GetContentType">
            <summary>
            Implementation of ISource.GetContentType
            </summary>
            <returns>The content type found (can be generic ItemField if could not be determined)</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TcmTargetFolder">
            <summary>
            Assembly attribute to set the target-folder to be used in the storage of an 
            assembly template building block. E.g.
            <code>[assembly: TcmTargetFolder("tcm:5-18213-2")]</code>
            </summary>
            <remarks>
            <para>
            The folder must be specified, and can be set as a WebDav URL or a TCM URI. This attribute
            is optional, in that it is also possible to specify the folder as a command line argument
            to the <c>TcmUploadAssembly.exe</c> utility.
            </para>
            <para>
            See the <a href="/Overview/Handling Pages/dotnet_templates.html">example template</a> for a usage of this attribute.
            </para>
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TcmTargetFolder.#ctor(System.String)">
            <summary>
            Constructor for the <c>TcmTargetFolder</c> attribute.
            </summary>
            <param name="folderId">The Tcm Uri or WebDav URL of the folder where this
            assembly template building block should be stored.</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TcmTargetFolder.FolderId">
            <summary>
            Folder id accessor.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TcmTemplateTitle">
            <summary>
            Assembly and class attribute to set the title to be used in the storage of 
            an assembly template building block and referencing template classes. E.g.
            <code>[assembly: TcmTemplateTitle("Name of Template Building Block")]</code>
            (for assembly titles) or
            <code>[TcmTemplateTitle("Name of .Net Template Class")]</code>
            (for .Net template classes).
            </summary>
            <remarks>
            <para>
            This attribute is optional, if not set the name of the assembly or class 
            is used as the name for storage.
            </para>
            <para>
            See the <a href="/Overview/Handling Pages/dotnet_templates.html">example template</a> for usages of this attribute.
            </para>
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TcmTemplateTitle.#ctor(System.String)">
            <summary>
            Constructor for the <c>TcmTemplateTitle</c> attribute.
            </summary>
            <param name="title">The name of the to be created template building block in the folder.</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TcmTemplateTitle.Title">
            <summary>
            Title accessor.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TcmTemplateParameterSchema">
            <summary>
            Class attribute to set the parameter schema to be associated
            with a template within an assembly.
            <example>
            <code>[TcmTemplateParameterSchema("tcm:0-183-8")]</code>
            <code>[TcmTemplateParameterSchema("resource:Tridion.ContentManager.Templating.Resources.Templates.ComponentQueryParameterSchema.xsd", "ComponentQuery.html")]</code>
            </example>
            </summary>
            <remarks>
            <para>
            In the Tcm Uri example, it is allowed that the URI-value has a zero
            publication id, in that case the publication id will be derived from the
            publication in which the template building block is stored.
            The uri referes to an existing schema.
            </para>
            <para>
            In the second example, the uri refers to a resource within the same assembly as the <see cref="T:Tridion.ContentManager.Templating.Assembly.ITemplate"/> implementation.
            The resource is addressed according to standard .Net convention: ProjectNamespace.[Folder].ResourceName.
            The parameters schema will be created. If it already exists, it will be overwritten.
            </para>
            <para>
            See the <a href="/Overview/Handling Pages/dotnet_templates.html">example template</a> for a usage of this attribute.
            </para>
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TcmTemplateParameterSchema.#ctor">
            <summary>
            Constructor for the <c>TemplateParameterSchema</c> attribute.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TcmTemplateParameterSchema.#ctor(System.String,System.String)">
            <summary>
            Constructor for the <c>TemplateParameterSchema</c> attribute.
            </summary>
            <param name="parameterSchemaUri">The Uri of the parameter schema to use for this template class.
            <list type="ordered">
            <item>A TcmUri like tcm:0-183-8 of a parameters schema already existing in the system. The publication id may be set to zero.</item>
            <item>A resource identifier like resource:ProjectNamespace.[Folder].EmbeddedResourceName. The parameters schema will be created.</item>
            </list>
            </param>
            <param name="helpFileName">An html file name of a file describing the parameters schema and its fields.
            </param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TcmTemplateParameterSchema.#ctor(System.String)">
            <summary>
            Constructor for the <c>TemplateParameterSchema</c> attribute.
            </summary>
            <param name="parameterSchemaUri">The Uri of the parameter schema to use for this template class.
            <list type="ordered">
            <item>A TcmUri like tcm:0-183-8 of a parameters schema already existing in the system. The publication id may be set to zero.</item>
            <item>A resource identifier like resource:ProjectNamespace.[Folder].EmbeddedResourceName. The parameters schema will be created.</item>
            </list>
            </param>        
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TcmTemplateParameterSchema.ParameterSchema">
            <summary>
            Schema value accessor.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TcmTemplateParameterSchema.HelpFileName">
            <summary>
            Help file name accessor
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TcmDefaultTemplate">
            <summary>
            Class attribute to indicate a class in an assembly is the default. E.g.
            <code>[TcmDefaultTemplate]</code>
            </summary>
            <remarks>
            <para>
            It is not allowed (i.e. an error) to make multiple template classes 
            within one assembly the default.
            </para>
            <para>
            If no template is set as a default, the first encountered in the assembly
            (when accessed through reflection) is treated as the default.
            </para>
            </remarks>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.AssemblyContentHandler">
            <exclude/>
            <summary>
            TemplateContentHandler implementation for assembly templates. 
            Note that this implementation may not make use of engines or packages, 
            since it runs in the context of a CM store/ retrieve.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.AbstractTemplateContentHandler">
            <summary>
            Helper class to make implementing a <see cref="T:Tridion.ContentManager.TemplateTypes.TemplateContentHandler"/>
            easier. An implementation of <c>(Abstract)TemplateContentHandler</c> is meant
            to perform pre and post processing in the storage and retrieval of templates.
            </summary>
            <remarks>
            <para>
            See the Adding a Template Type topic in SDL Tridion LiveContent 
            for more information on the role of the content handler within templating.
            </para>
            <para>
            The implementation of the template content handler is only necessary if you want to add
            a template type, and then only if you want to process references to other Tridion objects that are
            present in the template-content:
            <list type="bullet">
            	<item>It is possible to extract references to Tridion items that are present in the template,
            so that these references are managed.</item>
            	<item>It is possible to replace references to Tridion items that are present in the template,
            with URIs that can be localized.</item>
            	<item>For certain references to Tridion items (such as keywords and component links), it is
            possible to determine localized names of those items.</item>
            </list>
            </para>
            <para>
            A general extension of this class would implement <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.GetRelevantContentTypes"/> to
            indicate whether the content of the template is binary or text. Then the <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformValidateContent"/>
            method implementation should throw an exception if the template content is not syntactically correct.
            Then in its 
            <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformExtractReferences"/>
            implementation it would access the <see cref="P:Tridion.ContentManager.TemplateTypes.TemplateContentHandler.Content"/> or 
            <see cref="P:Tridion.ContentManager.TemplateTypes.TemplateContentHandler.BinaryContent"/> properties that contain the template content,
            get the references (web dav urls or TCM URIs) from it, and return that as a result.
            In the <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformSubstituteReferences(System.String[])"/> implementation it would get an array of replacment
            URIs or WebDav URLs for each extracted reference, that should be inserted in the template at
            the locations where the extracted references are found.
            Finally, it is possible to <i>override</i> the <see cref="M:Tridion.ContentManager.TemplateTypes.TemplateContentHandler.SubstituteRefTitles(System.String[])"/>
            method, which works like <c>PerformSubstituteReferences</c>, only now the titles of items are included.
            The <see cref="P:Tridion.ContentManager.TemplateTypes.TemplateContentHandler.TemplateId"/> and <see cref="P:Tridion.ContentManager.TemplateTypes.TemplateContentHandler.WebDavUrl"/>
            are also available for use in implementations.
            </para>
            <para>
            The actual implementation of the methods depend purely on the content of the templates you are
            definining a type for. What is very important is that you keep in mind in your implementation is that
            the <c>...Extract...</c> and <c>....Substitute....</c> methods are both called on a save, <b>and</b> on a
            retrieve. In the latter case previously abstracted TCM URIs are localized again. It is also important
            that in implementations only the methods and properties of the TemplateContentHandler are used, it
            is specifically not allowed to access the CMS directly in method implementations.
            </para>
            <para>
            (On top of a base template content handler, this class provides functionality to 
            check whether content is relevant, and logging of methods called, and is part
            of the templating API)
            </para>
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.HasRelevantContent">
            <summary>
            Method that determines whether Validate/ Extract/ Substitute methods
            should operate.
            </summary>
            <remarks>
            This method is mostly relevant for content handling when has-binary-content
            is true, because then the content handler can be invoked on binary as well
            as text-content, depending on the API-calls used.
            </remarks>
            <returns>Whether or not the content handler should be invoked</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.#ctor(Tridion.ContentManager.TcmUri)">
            <summary>
            Abstract constructor. Extensions of this class should make a constructor
            with a <see cref="T:Tridion.ContentManager.TcmUri"/> argument, and call this base-constructor.
            </summary>
            <param name="templateId">The TcmUri of the template being processed</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.ExtractReferences">
            <summary>
            Get all references from a template. Usually you will not use
            this method directly, see <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformExtractReferences"/> instead.
            </summary>
            <returns>the list of references found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.SubstituteReferences(System.String[])">
            <summary>
            Replace the existing references with the ones passed. Usually you will not use
            this method directly, see <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformSubstituteReferences(System.String[])"/> instead.
            </summary>
            <param name="newReferences">The list of replacement references to use</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.ValidateContent">
            <summary>
            Validate the content. Usually you will not use
            this method directly, see <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformValidateContent"/> instead.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.LogReferences(System.String,System.String[])">
            <summary>
            Utility method to generate a debug message for the references
            </summary>
            <param name="methodName">The methodname to include in the message</param>
            <param name="references">The references to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformExtractReferences">
            <summary>
            Implementations of this method should extract the references to Tridion items
            from the template content. It is allowed to have values in the result that are
            not valid Tridion references.
            </summary>
            <returns>The references in a string array.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformSubstituteReferences(System.String[])">
            <summary>
            Implementations of this method should replace previously extracted references
            to Tridion items in the template content with the <c>newReferences</c> ones.
            </summary>
            <remarks>
            The values in <c>newReferences</c> depend on the action being undertaken. In case
            the template is being saved, the substituted references will be publication independent
            TCM URIs. In case the template is being retrieved, the substituted references will
            be either TCM URIs localized for the current publication, or webdav URLs.
            </remarks>
            <param name="newReferences">The new references in a string array, where each
            entry matches the values found in <see cref="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformExtractReferences"/>.
            Some of the values in the array may be null, in case the extracted reference
            could not be resolved.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.PerformValidateContent">
            <summary>
            Implementations of this method should check whether the content of the template
            is syntactically correct. If not, they should throw an exception where the exception
            message clearly describes what is wrong with the template (this message may be shown
            to users saving the template).
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.GetRelevantContentTypes">
            <summary>
            Implementations of this method should indicate the content type this handler supports
            (binary or string).
            </summary>
            <returns>Either <c>RelevantContentTypes.String</c> or 
            <c>RelevantContentTypes.Binary</c></returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.RelevantContentTypes">
            <exclude/>
            <summary>
            Enumeration of content types that an individual content handler may support
            (can be both).
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.RelevantContentTypes.Binary">
            <summary>
            Binary content type
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.AbstractTemplateContentHandler.RelevantContentTypes.String">
            <summary>
            Text content type
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyContentHandler.#ctor(Tridion.ContentManager.TcmUri)">
            <summary>
            Constructor
            </summary>
            <param name="templateId">The TcmUri of the template being processed</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyContentHandler.GetRelevantContentTypes">
            <summary>
            The type of content for this content handler.
            </summary>
            <returns>Assembly templates are binaries</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyContentHandler.PerformExtractReferences">
            <summary>
            Dummy implementation of ExtractReferences
            </summary>
            <returns>the list of references found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyContentHandler.PerformSubstituteReferences(System.String[])">
            <summary>
            Dummy implementation of SubstituteReferences
            </summary>
            <returns>the list of references found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyContentHandler.PerformValidateContent">
            <summary>
            Validate the content, by attempting to load the assembly.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.AssemblyMediator">
            <exclude/>
            <summary>
            Mediator implementation for .Net assemblies. The template should contain a .Net assembly
            in this case.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.IMediator">
            <summary>
            A mediator is a class that knows how to interpret templates of a certain template type.
            Each mediator must implement this interface and be registered in the template type configuration. 
            For more information on creating a template type and a mediator, 
            see the Adding a Template Type topic in SDL Tridion LiveContent. 
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.IMediator.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            Execute the specified template in the context of the given package.
            The mediator is expected to be able to handle the template, as it is called
            based on the template types configuration.
            </summary>
            <remarks>
            <para>
            The implementation of a template type mediator is completely mediator specific, but
            generally speaking the goal is that the mediator evaluates the template content with
            the package acting as both the input and the output of the evaluation.
            </para>
            <para>
            Tridion .Net templating by default comes with mediators for the following template types:
            <list type="bullet">
            <item>.Net assembly template</item>
            <item>C# fragment template</item>
            <item>Dreamweaver template</item>
            <item>Compound template</item>
            </list>
            </para>
            </remarks>
            <param name="engine">The engine invoking the templating</param>
            <param name="template">The template to execute</param>
            <param name="package">The package with both the inputs and the outputs of the template</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.IMediator.Configure(Tridion.ContentManager.Templating.Configuration.MediatorElement)">
            <summary>
            Configure the mediator object, based on the configuration element of the mediator.
            </summary>
            <remarks>
            A mediator can be configured in the following way:
            <pre>
            &lt;mediator matchMIMEType="..." type="..." &gt;
              &lt;parameters&gt;
                &lt;parameter name="..." value="..."/&gt;
                &lt;parameter name="..." value="..."/&gt;
              &lt;/parameters&gt;
            &lt;/mediator&gt;
            </pre>
            You can then use the MediatorElement's <see cref="P:Tridion.ContentManager.Templating.Configuration.MediatorElement.ParameterCollection"/> property to get access to the set of configured parameters.
            </remarks>
            <param name="configuration">The configuration of this specific mediator</param>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Assembly.AssemblyMediator._log">
            Note on memory usage of the cache.
            Currently, assemblies are not unloaded because only one AppDomain is used, so these
            take up memory even if no longer cached.
            The keys are quite large, but are needed to make a correct comparison (MD5 hash cannot be used
            because not guaranteed unique).
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyMediator.Configure(Tridion.ContentManager.Templating.Configuration.MediatorElement)">
            <summary>
            Configure this mediator
            </summary>
            <param name="configuration">The configuration element for this mediator</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.AssemblyMediator.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            IMediator implementation
            Perform the transformation.
            </summary>
            <param name="engine">The engine that executes the transformation.</param>
            <param name="template">Reference to the template, the content of the template should
            be an assembly in this case.</param>
            <param name="package">The package to perform the transformation on.</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.AssemblyMediator.ClassName">
            <summary>
            Allow name of class to run to be set externally.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeContentHandler">
            <exclude/>
            <summary>
            TemplateContentHandler implementation for C# templates. 
            Note that this implementation may not make use of engines or packages, 
            since it runs in the context of a CM store/ retrieve.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeContentHandler.#ctor(Tridion.ContentManager.TcmUri)">
            <summary>
            Constructor
            </summary>
            <param name="templateId">The TcmUri of the template being processed</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeContentHandler.GetRelevantContentTypes">
            <summary>
            The type of content for this content handler.
            </summary>
            <returns>C# templates are strings</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeContentHandler.PerformExtractReferences">
            <summary>
            Find all the values of all Template TCM URIs in RunTemplate calls.
            </summary>
            <returns>the list of references found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeContentHandler.PerformSubstituteReferences(System.String[])">
            <summary>
            Replace template URIs in RunTemplate calls by their resolved references.
            </summary>
            <param name="newReferences">The list of substituted references, matching the list
            of extracted references</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeContentHandler.PerformValidateContent">
            <summary>
            Validate the content, by attempting to compile the template.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.ITemplate">
            <summary>
            <para>.Net templates should implement this interface to be able to be considered a template.</para>
            </summary>
            <remarks>
            <para>See the <see cref="N:Tridion.ContentManager.Templating.Assembly"/> namespace for attributes
            that can be set on these template implementing classes to specify their behavior.</para>
            <para>See the overview documentation for an 
            <a href="/Overview/Handling Pages/dotnet_templates.html">example template</a> implementing
            this interface.</para>
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.ITemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Execute the template in context of the given package.
            The template is expected to get the relevant <see cref="T:Tridion.ContentManager.Templating.Item"/>s from the package, manipulate
            them (with extra information coming from the engine) and then store the modified items back 
            into the package.
            </summary>
            <param name="engine">The engine can be used to retrieve additional information or execute additional actions.</param>
            <param name="package">The package provides the primary data for the template, and acts as the output.</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator">
            <exclude/>
            <summary>
            Mediator implementation for C# source code implementations.
            The C# code of a template should be a regular code block, and can be stored as 
             - A text-file (in ASCII-encoding) of a multimedia template.
             - A meta-data field named CSharpCode on a multimedia template.
             - A component field named CSharpCode of a regular component template.
            Three variables are offered to the code:
             - package (of type Package), representing the package that can be processed and
            updated by the template.
             - engine (of type Engine), representing the engine on which utility functions
            can be executed.
             - log (of type Logger), to which the template may log statements.
            Two special constructs may be used in the code
             - <![CDATA[<%@Import Namespace="...."%>]]> to add using statements to the code.
             - <![CDATA[<%! .... %>]]> to declare methods and constants. Within such a block, it
             - <![CDATA[<%! .... %>]]> to declare methods and constants. Within such a block, it
            is currently illegal to use the %&gt; character combination.
             - <![CDATA[<%RunTemplate AssemblyTemplate="tcm:x-y-z" Class="Full.Class.Name" %>]]> to call another template
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator.RunTemplate(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package,System.String,System.String)">
            <summary>
            Utility method to run a template specified by URI. If a classname is specified and
            the template to be executed is an assembly template, the classname is passed to the
            template execution.
            </summary>
            <remarks>
            This method is called from the generated code in TemplateProgramSkeleton.
            </remarks>
            <param name="engine">The context engine</param>
            <param name="package">The package the transformation is to run on</param>
            <param name="templateUri">The URI of the template to execute.</param>
            <param name="className">The name of the class to run.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator.Configure(Tridion.ContentManager.Templating.Configuration.MediatorElement)">
            <summary>
            Configure the mediator
            </summary>
            <param name="configuration">The configuration element for this mediator</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            IMediator implementation
            </summary>
            <param name="engine">Context engine</param>
            <param name="template">Template to execute</param>
            <param name="package">Package to execute the template on</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator.CompileAssembly(System.String)">
            <summary>
            Compile a template string into an assembly. Will either return a
            byte-array containing the assembly, or throw a TemplatingException
            in case of a compilation error.
            </summary>
            <param name="templateCode">The code to compile. See the header
            of this class for the format this class must have.</param>
            <returns>The compiled assembly</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator.GetRunTemplateAttributes(System.Text.RegularExpressions.Match)">
            <summary>
            Utility method for a found RunTemplateExpression regex match, to create a map
            of all attribute key-value pairs that were found.
            </summary>
            <remarks>
            Also checks that there are no unknown attributes specified, and that the Template
            attribute is present.
            </remarks>
            <param name="match">The RunTemplateExpression match to process</param>
            <returns>A map of found key value pairs. The values are returned as Capture elements
            so that their location in the original text can be found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator.ProcessRunTemplateCalls(System.String@)">
            <summary>
            Find all RunTemplate directives in a string, and replace them by RunTemplate method
            calls.
            </summary>
            <param name="templateCode">The C# source code to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.CSharpSourceCodeMediator.ReadFile(System.String)">
            <summary>
            Utility method to read a file into a byte-array
            </summary>
            <param name="path">The file to load</param>
            <returns>The content of the file (an exception is raised if the file does not exist)</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo">
            <summary>
            Class to parse/ represent the relevant information from a template assembly.
            </summary>
            <remarks>
            All templates in the assembly are determined, and a TemplateClassInfo object is 
            constructed per template.
            </remarks>
            <see cref="T:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.#ctor(System.String)">
            <summary>
            Constructor for a dummy information object
            </summary>
            <param name="name">The name to use for this dummy template info</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.#ctor(System.Byte[])">
            <summary>
            Constructor for an assembly
            </summary>
            <param name="assemblyContent">The assembly, as a byte array</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.#ctor(System.Reflection.Assembly)">
            <summary>
            Constructor for an assembly
            </summary>
            <param name="templateAssembly">The assembly, as a byte array</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.SetPublicationId(System.Int32)">
            <summary>
            Update the publication id used in this template info
            </summary>
            <remarks>
            Used to make all template IDs relative to this one.
            </remarks>
            <param name="publicationId">The publication id to use in 'relative' TCM URIs</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.ParseAssembly(System.Reflection.Assembly)">
            <summary>
            Construct a TemplateAssemblyInfo object by retrieving that information from 
            an assembly.
            </summary>
            <param name="templateAssembly">The content of an assembly as a byte array</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.GetAssemblyTypes(System.Reflection.Assembly)">
            <summary>
            Loads the template assembly types and handles errors specific to this operation.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.ParseAssemblyType(System.Type)">
            <summary>
            Check whether a type implements ITemplate, and if so get its information
            and add a new TemplateClassInfo to _templates.
            </summary>
            <param name="assemblyType">The type to process</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.DefaultTemplate">
            <summary>
            Property for the default template in the assembly
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.AssemblyName">
            <summary>
            Property for the name of the assembly (Assembly.FullName)
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.Assembly">
            <summary>
            Property for the assembly
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.LogicalName">
            <summary>
            Property for the name of the assembly (set in a AssemblyTemplateLocation assembly attribute,
            or Assembly.FullName if not set)
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.TargetFolder">
            <summary>
            Property for the target folder, or null if that was not set on the assembly.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.Templates">
            <summary>
            Property to get the map with information on all the templates
            in the assembly (logicalName->TemplateClassInfo).
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo.TemplateUri">
            <summary>
            Property for the component URI under which this assembly is stored in TCM.
            In case the storage location is not yet known, defaults to the null tcm uri: tcm:0-0-0.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage">
            <exclude/>
            <summary>
            Utility class meant to be used from the WebService that stores assembly,
            to store a template and generates template building blocks for each contained class.
            </summary>
            <remarks>
            E.g. if there is an assembly with in it two classes that implement ITemplate, three
            items would be generated on the first storage:
             - An assembly template building block for the assembly itself.
             - Two C# source code template building blocks with generated code referencing the other assembly
            template, and instatiating the class directly.
            
            If assemblies with varying contents are uploaded multiple times, generated items will be updated,
            added or removed depending on the changes in assemblies.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.PerformStoreTemplateAssembly(Tridion.ContentManager.Session,System.Byte[],System.Byte[],System.String,System.String,System.String)">
            <summary>
            Store an assembly as a template in Tridion CM.
            Also create a template item for each template class in the assembly.
            
            If the assembly is already present in the CM (and this is determined), the existing
            content is replaced.
            If templates created for the individual classes are present, they are only updated,
            not created again.
            If it is detected that classes are removed and a generated template is present for them, those
            template items are removed.
            </summary>
            <param name="session">The Session to use for the CM access (if null, a new one is created in the current context).</param>
            <param name="assemblyContents">The assembly to store, as a byte array.</param>
            <param name="pdbContents">The PDB debug symbol file contents, associated with the assembly. Optional, may be null</param>
            <param name="assemblyFileName">The original name of the assembly DLL</param>
            <param name="targetFolder">Override of the target folder set on the assembly (or null to not override)</param>
            <param name="associateBundle">If non-null, adds the templates to the bundle</param>
            <returns>A message indicating the success of the actions taken</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the assembly could not be read,
            or the folder reference does not point to an existing folder, or any non-resolvable error in
            creating or updating the related template building blocks is determined.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.#ctor">
            <summary>
            Constructor, to create an object instance.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.#ctor(Tridion.ContentManager.Session)">
            <summary>
            Constructor, to create an object instance.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.SetFolder(System.String)">
            <summary>
            Constructor (Public access is through the static method)
            </summary>
            <param name="folderUrlOrTcmUri">The URI or webdav URL of the folder in which
            the template is stored, or the template to update. The item must exist.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.StoreTemplateAssembly(System.Byte[],System.Byte[],System.String,System.String,System.String)">
            <summary>
            Store an assembly as a template in Tridion CM.
            Also create a template item for each template class in the assembly.
            </summary>
            <remarks>
            If the assembly is already present in the CM (and this is determined), the existing
            content is replaced.
            If templates created for the individual classes are present, they are only updated,
            not created again.
            If it is detected that classes are removed and a template is present for them, those
            template items are removed.
            </remarks>
            <param name="assemblyContents">The assembly to store, as a byte array.</param>
            <param name="pdbContents">The PDB debug symbol file contents, associated with the assembly. Optional, may be null</param>
            <param name="assemblyFileName">The original name of the assembly DLL</param>
            <param name="targetFolder">If non-null, overrides the target folder set on the assembly</param>
            <param name="associateBundle">If non-null, adds the templates to the bundle</param>
            <returns>A message indicating the success of the actions taken</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the assembly could not be read,
            or the folder reference does not point to an existing folder, or any non-resolvable error in
            creating or updating the related template building blocks is determined.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.ShouldUpdateParameterSchema(Tridion.ContentManager.Templating.Assembly.TemplateClassInfo,Tridion.ContentManager.Templating.Assembly.TemplateClassInfo,Tridion.ContentManager.Templating.Assembly.DotNetTemplate)">
            <summary>
            Utility method to determine whether a parameter schema should be set in a stored
            template to the value it has in the assembly being stored.
            </summary>
            <remarks>
            This method was introduced for TT59706. The general rules are:
             - If the parameter schema was changed in the assembly code, update it on the 
            template in the CMS.
             - If the parameter schema was manually changed in the CMS, do not update it (unless
            it was updated in the assembly).
            </remarks>
            <param name="newTemplateClass">The class information extracted from the to be stored
            assembly</param>
            <param name="currentTemplateClass">The class information extracted from the assembly 
            stored before (may be null).</param>
            <param name="storedTemplate">The stored template (which can be just newly created)</param>
            <returns>Whether or not the parameter schema of the stored template should be set to
            the value it has in the new template class</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.DetermineTemplateActions(System.Collections.Generic.IDictionary{System.String,Tridion.ContentManager.Templating.Assembly.DotNetTemplate},System.String,Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo,Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo,System.Collections.Generic.IList{Tridion.ContentManager.Templating.Assembly.TemplateClassInfo},System.Collections.Generic.IList{Tridion.ContentManager.Templating.Assembly.TemplateClassInfo},System.Collections.Generic.IList{Tridion.ContentManager.Templating.Assembly.TemplateClassInfo})">
            <summary>
            Based on the old assembly contents, new assembly contents, and the template building
            blocks in the CMS, construct list of actions to perform.
            </summary>
            <param name="existingTemplateBuildingBlocks">The template building blocks in the relevant folder.</param>
            <param name="currentAssemblyTbbUri">The uri of the existing assembly template (or null if the assembly template is not stored yet).</param>
            <param name="currentAssemblyInfo">The information about the currently stored assembly.</param>
            <param name="newAssemblyInfo">The information about the new to be stored assembly.</param>
            <param name="templatesToRemove">List of templates to remove (list is filled out by this method).</param>
            <param name="templatesToUpdate">List of templates to update (list is filled out by this method).</param>
            <param name="templatesToAdd">List of templates to add (list is filled out by this method).</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.CheckContents(Tridion.ContentManager.Templating.Assembly.DotNetTemplate,Tridion.ContentManager.Templating.Assembly.TemplateClassInfo,System.String)">
            <summary>
            Method to check the contents of a class C# template building block, to check
            whether a) the parameter schema and b) the content match with what would be
            available if this class was generated.
            </summary>
            <remarks>
            Both the string content and the parameter schema properties are checked.
            </remarks>
            <param name="tbb">The template building block item to check.</param>
            <param name="templateInfo">The information as it is expected to be stored
            in the template building block.</param>
            <param name="currentAssemblyTbbUri">The TCM URI of the assembly template
            that should be referenced.</param>
            <returns>The comparison result (see TemplateContentState enum for details).</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.AddDebugStatusMessage(System.Collections.Generic.IList{System.String},System.String,System.Object[])">
            <summary>
            Helper method for StoreTemplateAssembly, to construct, log, and add a localized message
            </summary>
            <param name="messages">The list to add the message to</param>
            <param name="localizationId">The resource id of the localization string</param>
            <param name="parameters">The parameters to pass to the localizable message</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.ConstructTemplateReferenceContents(Tridion.ContentManager.Templating.Assembly.TemplateAssemblyInfo,Tridion.ContentManager.Templating.Assembly.TemplateClassInfo)">
            <summary>
            Utility method to create a generated reference C# code fragment
            </summary>
            <param name="assemblyInfo">The assembly template to create the generated code for (URI is used).</param>
            <param name="templateInfo">The class template to create the generated code for (full classname is used).</param>
            <returns>A constructed C# fragment</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.GetBuildingBlockList">
            <summary>
            Construct a list of all template building blocks present in the current folder.
            </summary>
            <returns>The construct list, in a map of name, template</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.GetDotNetTemplate(System.String,System.Boolean)">
            <summary>
            Get the template object.
            </summary>
            <param name="uri">The TCM URI of the template</param>
            <param name="readWrite">Whether the template should be writable</param>
            <returns>The template, that may be altered</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.CreateNewTemplate">
            <summary>
            Create a new template building block, in the context folder.
            </summary>
            <returns>The newly created template building block.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.GetTomObject(System.String,System.Boolean)">
            <summary>
            Retrieve a TOM.NET object for a given ID, or null in case it cannot be found.
            </summary>
            <param name="itemUriOrWebDavUrl">The TCM URI or webdav URL of the item to retrieve.</param>
            <param name="readWrite">True in case the item should become accessible for writing.</param>
            <returns>A TOM.NET object, or null in case the object cannot be found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.GetParametersSchemaList">
            <summary>
            Construct a list of all parameters schemas present in the current folder.
            </summary>
            <returns>The construct list, in a map of name, template</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.Log">
            <summary>
            Access the logger object of this class.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TemplateAssemblyStorage.TemplateContentState">
            <summary>
            Internal enumeration, used for result of CheckContents method
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.DotNetTemplate">
            <summary>
            Class internal to TemplateAssemblyStorage, representing a .Net based template (either assembly or C# source)
            </summary>
            <remarks>
            All access to TemplateBuildingBlocks is wrapped in this code.
            Together with the methods CreateNewTemplate, CreateBuildingBlockList, CreateNewTemplate, and the constructor
            in TemplateAssemblyStorage, they represent all access to the TOM Interop code.
            This makes it easier to unit-test, and replace later with a possible read/write TOM.Net.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.SaveBinaryContent(System.Byte[],System.String)">
            <summary>
            Set new binary, content, and immediately save the template
            </summary>
            <remarks>
            The immediate saving is a side-effect from the temporary file being necessary
            in changing the content.
            </remarks>
            <param name="newValue">The new content</param>
            <param name="fileName">The filename to use for the binary</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.Delete">
            <summary>
            Delete a template
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.Save">
            <summary>
            Save a template
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.ID">
            <summary>
            Property for the TCM URI of the template
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.Title">
            <summary>
            Property for the name of the template
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.Content">
            <summary>
            Property for the C# content of the template
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.BinaryContent">
            <summary>
            Property for the Assembly content of the template.
            If set, the binary is also saved
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.TemplateType">
            <summary>
            Property for the template type of the template
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.DotNetTemplate.ParameterSchema">
            <summary>
            Property for the parameter schema (as a string) property of the template.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Assembly.TemplateClassInfo">
            <summary>
            Structure with useful information about one ITemplate implementing class in an assembly
            </summary>
            <remarks>
            Used from TemplateAssemblyStorage/ TemplateAssemblyInfo for data-sharing.
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateClassInfo.FullClassName">
            <summary>
            Readonly property for the fully qualified classname of the class
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateClassInfo.Name">
            <summary>
            Readonly property that returns the fully qualified classname, or a user defined
            classname if one has been determined.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateClassInfo.ParameterSchemaUri">
            <summary>
            Readonly property for the parameter schema URI of the class, if one was defined in the assembly.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateClassInfo.TemplateItemUri">
            <summary>
            Property to indicate the URI of the existing template for this item.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Assembly.TemplateClassInfo.PreviousTemplateInfo">
            <summary>
            Property with the class information of this same template in the previous
            class.
            </summary>
            <remarks>There is no guarantee this property is always set correctly (as
            it is the responsibility of the code using this class).</remarks>
        </member>
        <member name="T:Tridion.ContentManager.Templating.ComponentPresentation">
            <summary>
            A ComponentPresentation object identifies a component and a component template using their TCM URIs.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ComponentPresentation.XmlSerializableSchema">
            <summary>
            Schema as expected by ReadXml and WriteXml.
            Note that this schema is propably not used at the moment, since the
            documentation explained the schema is not used in serialization, only
            in webservice contexts.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentation.#ctor(Tridion.ContentManager.TcmUri)">
            <summary>
            Creates a new ComponentPresentation object based on the given component URI. The TemplateURI of the
            resulting ComponentPresentation will be set to null.
            </summary>
            <param name="componentURI">The URI of the component in this component presentation</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentation.#ctor(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri)">
            <summary>
            Creates a new ComponentPresentation object based on the given component URI and template URI.
            </summary>
            <param name="componentURI">The URI of the component in this component presentation</param>
            <param name="templateURI">The URI of the template in this component presentation</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentation.GetSchema">
            <exclude/>
            <summary>
            The API documentation recommends not to implement this method, but instead use
            a XmlSchemaProvider attribute (but you still need to implement the interface for
            the compiler).
            </summary>
            <returns>Never returns</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentation.ComponentPresentationSchema(System.Xml.Schema.XmlSchemaSet)">
            <exclude/>
            <summary>
            Alternative implementation of GetSchema, this method name is referred to
            in the XmlSchemaProvider attribute on the class.
            </summary>
            <param name="xmlSchemaSet">The set of schemas to add the serialization schema to</param>
            <returns>The root element of the schema</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentation.ReadXml(System.Xml.XmlReader)">
            <summary>
            Custom XML deserialization code, that processes URI strings instead of TcmUri
            objects (that cannot be serialized).
            </summary>
            <param name="reader">The reader, pointing to a serialized ComponentPresentation object</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentation.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Custom XML serialization code, that processes URI strings instead of TcmUri
            objects (that cannot be serialized).
            </summary>
            <param name="writer">The writer, that has just started writing a serialized ComponentPresentation object</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ComponentPresentation.ComponentUri">
            <summary>
            The URI of the component in this component presentation.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ComponentPresentation.TemplateUri">
            <summary>
            The URI of the template in this component presentation. Note that this property may be null, in 
            which case the component presentation doesn't have a template.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.IComponentPresentationList">
            <summary>
            A type safe list of component presentation objects. This list mostly provides a more readable 
            alterative to <c>IList&lt;ComponentPresentation&gt;</c>, especially when using the list in another
            type-safe/generic structure.
            </summary>
            <seealso cref="T:Tridion.ContentManager.Templating.ComponentPresentation"/>
            <seealso cref="T:Tridion.ContentManager.Templating.ComponentPresentationList"/>
        </member>
        <member name="T:Tridion.ContentManager.Templating.ComponentPresentationList">
            <summary>
            A implementation of a list of components based on the generic List type. Aside from a more readable
            alternative to <c>List&lt;ComponentPresentation&gt;</c> this class also provides a few convenience
            methods that allow the list to be serialized to and from XML.
            </summary>
            <seealso cref="T:Tridion.ContentManager.Templating.IComponentPresentationList"/>
            <seealso cref="T:Tridion.ContentManager.Templating.ComponentPresentation"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentationList.#ctor">
            <summary>
            Initializes a new instance of the ComponentPresentationList class that is empty and has the 
            default initial capacity. 
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentationList.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the ComponentPresentationList class that is empty and has the 
            specified initial capacity. 
            </summary>
            <param name="size">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentationList.FromXml(System.String)">
            <summary>
            Initializes a new instance of the ComponentPresentationList class that contains the component
            presentations in the specified xml.
            </summary>
            <remarks>
            The XML is deserialized using <c>XmlSerializer</c>.
            </remarks>
            <param name="xml">The xml describing the component presentations that you want to be part of 
            the list</param>
            <returns>the newly initialized list</returns>
            <seealso cref="T:System.Xml.Serialization.XmlSerializer"/>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentationList.ToXml">
            <summary>
            Returns the XML representation of the contents of this list. The list can later be reconstructed
            from this XML using the <c>FromXml</c> method.
            </summary>
            <returns>the XML representation of the content of this list</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentationList.ToXml(System.Collections.Generic.IList{Tridion.ContentManager.Templating.ComponentPresentation})">
            <summary>
            Returns the XML representation of the contents of the specified. The list can later be reconstructed
            from this XML using the <c>FromXml</c> method.
            </summary>
            <param name="list">The component presentation list to convert to an XML representation</param>
            <returns>the XML representation of the content of the specified list</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentationList.Equals(System.Object)">
            <summary>
            Override of equals method
            </summary>
            <param name="obj">The object to compare to</param>
            <returns>Whether or not the passed component presentation list contains the same data</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ComponentPresentationList.GetHashCode">
            <summary>
            Override of hashcode, to construct a hashcode based on teh actual contents
            of this method
            </summary>
            <returns>A hashcode for this object</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Compound.CompoundTemplate">
            <summary>
            This class models a compound template, which is a template that invokes other templates with
            specific parameters in a certain order.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplate.#ctor(System.Xml.XmlElement)">
            <summary>
            Creates a new compound template object based on the current node.
            </summary>
            <param name="source">the element containing the definition of the compound template. The
            root should be the CompoundTemplate element.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplate.#ctor(System.String)">
            <summary>
            Creates a new compound template object based on the given XML.
            </summary>
            <param name="source">the XML from which to read the definition of the compound template.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplate.GetTemplateInvocations">
            <summary>
            Returns all template invocations that can be found in the given component.
            </summary>
            <returns>all template invocations that can be found in the given component</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler">
            <summary>
            TemplateContentHandler implementation for compound templates. 
            Note that this implementation may not make use of engines or packages, 
            since it runs in the context of a CM store/ retrieve.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.#ctor(Tridion.ContentManager.TcmUri)">
            <summary>
            Constructor
            </summary>
            <param name="templateId">The TcmUri of the template being processed</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.SubstituteRefTitles(System.String[])">
            <summary>
            Override of content handler to fill in reference titles in
            links and keywords.
            </summary>
            <remarks>
            The data is updated relative to the reference attribute
            For links, an xlink:title attribute is added if the title is available
            For keywords, the title is set as value for the replacement
            </remarks>
            <param name="newRefTitles">The updated titles for the extracted references (if available</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.GetRelevantContentTypes">
            <summary>
            The type of content for this content handler.
            </summary>
            <returns>Compound templates are strings</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.PerformExtractReferences">
            <summary>
            Get all references to templates referenced in the template invocations
            </summary>
            <returns>the list of references found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.IsTridionReference(System.String)">
            <summary>
            Check whether the passed reference value is a TCM URI or a WebDAV URL
            </summary>
            <param name="referenceValue">The parameter to check</param>
            <returns>Whether or not this value is to be considered a tridion reference</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.PerformSubstituteReferences(System.String[])">
            <summary>
            Replace the existing references with the ones passed
            </summary>
            <param name="newReferences">The list of new references to store</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.PerformValidateContent">
            <summary>
            Validate the content.
            </summary>
            <remarks>
            At the moment implemented by checking whether the XML parses (not whether its structure is valid
            (there is no access to schemas to e.g. check the parameters))
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.GetReferenceAttributes">
            <summary>
            Get all the xlink:href references out of the current compound template document
            </summary>
            <returns>A list of references found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.InitializeContent">
            <summary>
            If not previously done, construct the compound template based on the currently
            set content.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateContentHandler.SetDocumentAsContent">
            <summary>
            Serialize the XML document representing the data, and set that as
            Content of this content handler (should be called after changing the
            document).
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Compound.CompoundTemplateMediator">
            <summary>
            This class interprets a compound template and executes all sub-templates within it.
            A compound template is implemented in TCM as a component, with the following namespace: 
            <c>http://www.tridion.com/ContentManager/5.3/CompoundTemplate</c>
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Compound.CompoundTemplateMediator.CompoundTemplateNamespace">
            <summary>
            The namespace that a component must be in to be considered a compound template.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateMediator.Configure(Tridion.ContentManager.Templating.Configuration.MediatorElement)">
            <summary>
            Configure the mediator
            </summary>
            <param name="configuration">The configuration element for this mediator</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Compound.CompoundTemplateMediator.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            Perform the transformation of the specified compound template in the context of the given package.
            </summary>
            <param name="engine">The engine executing the mediator</param>
            <param name="templateToTransform">The template to execute</param>
            <param name="package">The package with both the inputs and the outputs of the template</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.DebuggingElement">
            <summary>
            Configuration element for debugging configuration
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.DebuggingElement.GetMinimumTemplatingLogLevel">
            <summary>
            Determine the configured minimum templating log level.
            </summary>
            <returns>The configured (or default) log level as a TraceEventType.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.DebuggingElement.GetEventType(System.String)">
            <summary>
            Convert a log level string into a TraceEventType enum value.
            </summary>
            <param name="logLevelString">The string to convert</param>
            <returns>The matching TraceEventType</returns>
            <exception cref="T:System.Configuration.ConfigurationErrorsException">In case the logLevelString is not valid</exception>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.DebuggingElement.PdbLocation">
            <summary>
            Gets or sets the directory of PDB files
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.DebuggingElement.DebuggerWorkingDirectory">
            <summary>
            Gets or sets the directory for the debugger.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.DebuggingElement.MinimumTemplatingLogLevel">
            <summary>
            Gets or sets the templating log level.
            </summary>
            <remarks>
            This log level sets the minimum level of log-messages before they are sent to
            the configured logging. This option has no effect when using the Template
            Builder.
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.DebuggingElement.Force32Bit">
            <summary>
            Gets or sets a value indicating whether the debugger should be forced to run in 32 bit.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.MediatorCollection">
            <summary>
            Configuration class to represent a list of MediatorElements
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.MediatorCollection.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.MediatorCollection.CreateNewElement">
            <summary>
            Creates a new MediatorElement.
            </summary>
            <remarks>
            Part of ConfigurationElementCollection implementation.
            </remarks>
            <returns>A new MediatorElement</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.MediatorCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Determine the key of a specific configuration element.
            </summary>
            <remarks>
            Part of ConfigurationElementCollection implementation.
            </remarks>
            <param name="element">The Mediator to determine the key for</param>
            <returns>A determined key-value for this configuration element</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.MediatorCollection.Add(Tridion.ContentManager.Templating.Configuration.MediatorElement)">
            <summary>Adds a MediatorElement to a MediatorCollection.</summary>
            <remarks>For testing.</remarks>
            <param name="mediator">The MediatorElement to add.</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.MediatorElement">
            <summary>
            Configuration class to represent a the configuration of one mediator
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.MediatorElement.#ctor">
            <summary>
            Constructor (used from MediatorCollection)
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.MediatorElement.ClassName">
            <summary>
            Property for the classname of the mediator
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.MediatorElement.MatchMimeType">
            <summary>
            Property for the MIME-type of the mediator that is matched.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.MediatorElement.AssemblyPath">
            <summary>
            Optional property for assembly path of the mediator.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.MediatorElement.ParameterCollection">
            <summary>
            Gets and sets the Parameter-collection property
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.TemplateUploadElement">
            <summary>
            Configuration element for templating upload element.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Configuration.TemplateUploadElement.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplateUploadElement.AssemblyTemplateMimeType">
            <summary>
            Property for the Mime-Type of assembly templates
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplateUploadElement.CSharpTemplateMimeType">
            <summary>
            Property for the Mime-Type of C# templates
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplateUploadElement.CompoundTemplateMimeType">
            <summary>
            Property for the Mime-Type of Compound templates
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplateUploadElement.DreamweaverTemplateMimeType">
            <summary>
            Property for the Mime-Type of Compound templates
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Configuration.TemplatingSettings">
            <summary>
            Configuration class to represent the (top-level) configuration of templating.
            </summary>
            <remarks>
            For example:
            	<tridion.templating>
            		<debugging pdbDirectory="c:\pdbLocation" debuggerTempDirectory="c:\temp" templatingLogLevel="Info"/>
            		<mediators>
            			<mediator type="Some.Full.ClassName" matchMIMEType="major/minor">
            				<!-- optional -->
            				<parameters>
            					<parameter name="parameterNameOfThisMediator" value="parameterValue" />
            				</parameters>
            			</mediator>
            			...
            		</mediators>
                </tridion.templating>
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.TemplatingConfigurationSectionName">
            <summary>
            The name used for the templating configuration section.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.DebuggingElement">
            <summary>
            Gets or sets the Debugging-element property
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.TemplateUploadElement">
            <summary>
            Gets or sets the optional TemplateUpload-element property
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.MediatorCollection">
            <summary>
            Gets or sets the Mediators-collection property
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.FunctionSourceCollection">
            <summary>
            Gets or sets the custom function source collection.
            </summary>
            <value>The custom function source collection.</value>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.LegacyNumberParsing">
            <summary>
            Gets or sets whether to use legacy number parsing (before Suite 2009 SP1)
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.DefaultTemplatesScriptCollection">
            <summary>
            Gets or sets the default templates setup scripts collection
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.CmePreviewUrl">
            <summary>
            Gets or sets the CME Preview Path URL
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Configuration.TemplatingSettings.Name">
            <summary>
            Gets the name of the section.
            </summary>
            <value>
            The name of the section.
            </value>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler">
            <summary>
            TemplateContentHandler implementation for dreamweaver templates. 
            Note that this implementation may not make use of engines or packages, 
            since it runs in the context of a CM store/ retrieve.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.#ctor(Tridion.ContentManager.TcmUri)">
            <summary>
            Constructor
            </summary>
            <param name="templateId">The TcmUri of the template being processed</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.GetRelevantContentTypes">
            <summary>
            The type of content for this content handler.
            </summary>
            <returns>Dreamweaver templates are strings</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.PerformExtractReferences">
            <summary>
            ExtractReferences implementation.
            </summary>
            <remarks>
            In the string content find all:
             - Possible multimedia references
             - tridion:href references
             - tridion:excludetemplateuri references
            For all, if the reference is either found to be a path, or a TCM URI:
             1. Add the path (full webdav URL if relative) to the references list
             2. In the underlying content, replace the found reference by a numbered placeholder, which
            can easily be found/ replaced in the next step.
            </remarks>
            <returns>A list of found references</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.PerformSubstituteReferences(System.String[])">
            <summary>
            SubstituteReferences implementation.
            </summary>
            <remarks>
            In the string content preprocessed by ExtractReferences, find all placeholders and
            simply replace them with the newReferences value of the same index.
            ExtractReferences must have been called before on this method is called.
            </remarks>
            <param name="newReferences">The list of replacement references, that must match the list
            provided by ExtractReferences.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.PerformValidateContent">
            <summary>
            Implementation of ValidateContent
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.AddExtractedReference(System.Collections.Generic.IList{System.String},System.String)">
            <summary>
            Update a list of extracted references, and construct a placeholder to later be used
            in SubstituteReferences
            </summary>
            <param name="extractedReferences">List of already found references</param>
            <param name="extractedReference">New reference to add to the list</param>
            <returns>A unique string, containing the index of the found reference, this string is
            not expected to be found anywhere in the document</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.GetWebDavPrefix">
            <summary>
            Determine '/webdav/', but from the WebDavUrl in case it is configured differently
            </summary>
            <returns>"/webdav/"</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.FormatReference(System.String)">
            <summary>
            Resolve a path (can also be a TcmUri) from relative to absolute,
            if found to be a relative path, or null in case the tridionReference
            is not a tridion reference after all.
            </summary>
            <remarks>
            Because no CM access is permitted here, in case a path is the return value
            is is not known whether this is really a valid reference.
            </remarks>
            <param name="tridionReference">The possible tridion reference, which can either be
            a TCM URI or a (perhaps relative) webdav URL, or neither (just a path or URL)</param>
            <returns>null in case the string is found to be not a TCM URI or a webdav URL,
            or the tridionReference found (possibly made absolute)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.ResolveWebDavUrl(System.String,System.Boolean,System.String)">
            <summary>
            Determine a (possible) WebDAVURL. and normalize it. This method
            does not check whether the URL leads to a valid item in the CMS.
            </summary>
            <param name="webDavBaseUrl">The base URL where possible relative URLs
            are determined relative to.</param>
            <param name="baseUrlIsDirectory">What kind of URL is being passed, to a file or a folder</param>
            <param name="urlToResolve">The (perhaps) relative URL</param>
            <returns>The urlToResolve, made absolute if it was relative, and URL encoded</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.NormalizeWebDavUrl(System.String)">
            <summary>
            Make a webDavURL more standard for a query lookup:
             - replace any \'s by /'s
             - Remove . and .. from the paths
             - Perform URL escaping
            This should a full URL
            </summary>
            <param name="inputWebDavUrl">The string to normalize</param>
            <returns>The normalized string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverContentHandler.FormatSubstitutionValue(System.String,System.String)">
            <summary>
            Utility method for SubstituteReferences.
            Format a substitution-value, for inclusion in the dreamweaver template
            </summary>
            <remarks>
            In practice this means that in case of a WebDAV URL, an attempt is made
            to make it relative.
            </remarks>
            <param name="baseWebDavUrl">The WebDAV URL of the directory of the template. This path is
            expected to be properly normalized</param>
            <param name="newReference">The reference offered to SubstituteReferences, expected
            to be a TCM URI or fully normalized WebDAV URL</param>
            <returns>Either the newReference unchanged, or a relative WebDAV URL if one
            could be determined</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplatingErrorCode">
            <exclude/>
            <summary>
            Error codes used in logging and exceptions
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplatingErrorCode.Templating">
            <summary>
            Basic templating error code
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplatingLoggingCategory">
            <exclude/>
            <summary>
            Categories used in logging
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplatingLoggingCategory.Templating">
            <summary>
            Basic templating category
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.PackageItemType">
            <summary>
            Types of content of package items, see the <see cref="P:Tridion.ContentManager.Templating.Item.Type">Item.Type</see> property
            (An item's content can be of type <c>String</c>, <c>Stream</c>, or <c>Xml</c>).
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.PackageItemType.String">
            <summary>
            String (text) content based item package item type.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.PackageItemType.Stream">
            <summary>
            Binary stream content based item package item type.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.PackageItemType.Xml">
            <summary>
            XML content based item item package item type.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator">
            <exclude/>
            <summary>
            Class that can process expressions, that may occur in 
            	@@expression@@
            	<!-- TemplateBeginIf cond="..." -->
            	<!-- TemplateExpr expr="..." -->
            etc. blocks.
            Both the current package content as well as the currently determined
            expression context are taken into account in the evaluation.
            
            Only expressions in the Dreamweaver syntax are correctly processed, this syntax is described in the
            'The template expression language' dreamweaver help-topic, which in summary is:
            The following features and operators are supported:
             - numeric literals, string literals (double-quote syntax only), Boolean literals (true or false) 
             - variable reference (see the list of defined variables later in this section) 
             - field reference (the "dot" operator) 
             - unary operators: +, -, ~, ! 
             - binary operators: <![CDATA[+, -, *, /, %, &, |, ^, &&, ||, <, <=, >, >=, ==, !=, <<, >> ]]>
             - conditional operator: ?: 
             - parentheses: () 
            The following data types are used: Boolean, IEEE 64-bit floating point, string, and object. Dreamweaver templates do not support the use of JavaScript "null" or "undefined" types. Nor do they allow scalar types to be implicitly converted into an object; thus, the expression "abc".length would trigger an error, instead of yielding the value 3.
            The only objects available are those defined by the expression object model. The following variables are defined:
            _document, _repeat, _index, _numRows, _isFirst._isLast, _prevRecord, _nextRecord, and _parent.
            
            The following internal functions are provided:
            StringLength(string), to determine the string length of an argument
            RenderComponentPresentation([string componentUri, string templateUri]), to get the content
            of a component presentation (if the parameters are not specified, it attempts to get them from the package context)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.#ctor(Tridion.ContentManager.Templating.Package)">
            <summary>
            Construct a new ExpressionEvaluator, based on context
            </summary>        
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.EvaluateExpressionToBool(System.String)">
            <summary>
            Evaluate a script expression within the current context, where
            the result is expected to be a boolean.
            </summary>
            <param name="expression">The expression to evaluate</param>
            <returns>
            True in case the expression resolves to true, false in all other cases
            </returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the script could not be executed</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.EvaluateExpressionToString(System.String)">
            <summary>
            Evaluate a script expression within the current context, where
            the result is expected to be a string.
            </summary>
            <param name="expression">The expression to evaluate</param>
            <returns>The string-result of the expression</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the script could not be executed</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.ProcessVariablesInExpression(System.String)">
            <summary>
            Take an expression, whose format is described in the class header, and
            replace all variable references by their string representation, or an
            empty string if it cannot be evaluated.
            E.g. the input expression is
              Component.Schema.Name == "My first Schema"
            and Component.Schema.Name evaluates to "Some Schema", then the expression
            is rewritten to
              "Some Schema" == "My first Schema"
            Also does some fixup on single quotes on single assignments
            	Component.Schema.Name = 'My first Schema'
            will produce the same output above.
            
            Only Dreamweaver like expressions are expected, so that a lot of shortcuts
            can be taken (so conditional constructs except ?:, statements, and
            method calls are all not supported).
            </summary>
            <param name="expression">The expression to process</param>
            <returns>A JScript expression that can be run</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.ProcessNonQuotedParts(System.String,Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.StringProcessorDelegate,System.Boolean)">
            <summary>
            Process a string, that may contain quoted parts.
            For the sections not in quotes, call the processor argument, and
            append the result of that to the output.
            For the sections in quotes, copy the input over to the output,
            but replace possible single quotes by double quotes.
            E.g. foo='bar'
            is replaced by
               processor("foo=") + @"""bar""";
            </summary>
            <param name="inputExpression">The input to process</param>
            <param name="processor">The stringprocessor delegate to call on non-quoted parts</param>
            <param name="firstPass">Whether this is the initial run of ProcessNonQuotedParts (to ensure
            some processing actions are not performed multiple times)</param>
            <returns>The processed string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.FindEndQuote(System.String,System.Int32)">
            <summary>
            Find an unescaped end-quote in a string, to find a string literal.
            </summary>
            <param name="inputExpression">The string to find the literal in</param>
            <param name="firstQuoteIndex">The position of the start-quote (may be ' or ")</param>
            <returns>The position of a matching close-quote, or the string-length if there is no 
            matching end-quote</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.EvaluateVariablesInExpression(System.String)">
            <summary>
            StringProcessorDelegate implementation:
            Look for variable references (which are taken to be
            characterarray with leading alpha-character and possible .'s and _'s), 
            and replace those occurrences a quoted string containing their result.
            
            See also ProcessVariablesInExpression
            </summary>
            <param name="input">The text to process</param>
            <returns>The string, with variable references replaced by a string-value</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.EscapeString(System.String)">
            <summary>
            Escape a string in such a way such that it can be used in a constant in Javascript.
            This means:
              - Escape '"', otherwise the string is terminated.
              - Escape line-breaks, otherwise the line of code would be terminated.
            Escaping in JScript occurs with a \
            </summary>
            <param name="input">The unescaped string</param>
            <returns>The input-string, with '"' replaced by '\''"', \n by '\''n' and
            \r by '\''r'</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.EqualityOperatorFixup(System.String)">
            <summary>
            StringProcessorDelegate implementation to process a non-quoted section of 
            a script so that it looks more like Javascript. Dreamweaver 
            allows for '=' to be a comparison, this will be fixed up to '=='
            </summary>
            <param name="input">Input string to perform conversion on</param>
            <returns>The fixed up JScript fragment</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.HtmlEncodeResult">
            <summary>
            Property that indicates whether the output of this expression should be
            treated as HTML.
            </summary>
            <remarks>
            If set to true, the return value will Html-encode non-HTML parts of the value.
            (otherwise values are untouched, the default)
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.ResolveHtmlAsRTFContent">
            <summary>
            Property that indicates whether html parts of the expression should be
            treated as RTF fields (so TemplateUtilities.ResolveRichTextFieldXhtml
            will get called on RTF fields).
            </summary>
            <see cref="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.ResolveRichTextFieldXhtml(System.String)"/>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Expression.ExpressionEvaluator.StringProcessorDelegate">
            <summary>
            Delegate used in ProcessNonQuotedParts, whose implementations
            should process part of a string that is not a quoted section.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.PublishingContext">
            <summary>
            This class represents the <see cref="N:Tridion.ContentManager.Publishing"/> context
            of a publication action.
            </summary>
            <remarks>
            This object can be retrieved on the <see cref="T:Tridion.ContentManager.Templating.Engine"/> object, in the 
            <see cref="P:Tridion.ContentManager.Templating.Engine.PublishingContext"/> property.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.PublishingContext.#ctor(Tridion.ContentManager.Publishing.Resolving.ResolvedItem,Tridion.ContentManager.Publishing.PublishInstruction,Tridion.ContentManager.CommunicationManagement.PublicationTarget,Tridion.ContentManager.Publishing.Rendering.RenderedItem,Tridion.ContentManager.Publishing.Rendering.RenderContext)">
            <summary>
            Constructor, with the exact fields passed to an IRenderer interface
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.PublishingContext.ResolvedItem">
            <summary>
            The resolved item that is to be rendered. 
            </summary>
            <remarks>
            When used through the Template Builder, the
            template is not set (as it need not have been saved yet)
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.PublishingContext.PublishInstruction">
            <summary>
            The publish instruction for this publication action.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.PublishingContext.PublicationTarget">
            <summary>
            The publication target used for this publishing action.
            </summary>
            <remarks>
            In preview mode or when used from the Template Builder,
            this object is not set.
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.PublishingContext.RenderedItem">
            <summary>
            The rendered item of this publishing action.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.PublishingContext.RenderContext">
            <summary>
            The render context of this publishing action
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.SourceUtilities">
            <summary>
            Utility class to make usage of <see cref="T:Tridion.ContentManager.Templating.ISource"/>s easier, with both methods
            to use on <c>ISource</c> objects, as well as methods to help create <c>ISource</c>
            implementation classes.
            </summary>
            <remarks>
            This class acts as a static function library, it is not needed to instantiate it.
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.SourceUtilities.QualifiedNameSeparator">
            <summary>
            The seperator used in fully qualified names in sources ('.').
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.SourceUtilities.SourceValueSeparator">
            <summary>
            Seperator to use when a multi-source value is requested (',').
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.RemoveFirstQualifiedName(System.String)">
            <summary>
            Remove the head part of a fully qualified name.
            E.g., for a name like 'foo.bar.z', return 'bar.z'.
            </summary>
            <param name="qualifiedName">The qualified name to remove the first part of.</param>
            <returns>The fully qualified name, minus the first part.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetFirstQualifiedName(System.String)">
            <summary>
            Get the head part of a fully qualified name.
            E.g., for a name like 'foo.bar.z', return 'foo'.
            </summary>
            <param name="qualifiedName">The qualified name to get the first part of</param>
            <returns>The first part of a fully qualified name.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetValueAsHtml(Tridion.ContentManager.Templating.ISource,System.String)">
            <summary>
            Determine the (possibly concatenated set of source-value), HTML
            escaped (so it can be used as an HTML fragment).
            </summary>
            <remarks>
            The underlying value of a source may represent HTML or regular text. In case
            of regular text, it needs to be HTML-escaped to be able to include it in a larger
            HTML document.
            </remarks>
            <param name="source">The source to evaluate.</param>
            <param name="fullyQualifiedName">The source expression to evaluate.</param>
            <returns>The found string value (or null if the fullyQualifiedName could
            not be resolved), in a form that can be included in a larger HTML document.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetValueAsNumbers(Tridion.ContentManager.Templating.ISource,System.String)">
            <summary>
            Utility function to access a source as list of numbers.
            </summary>
            <remarks>
            If the fully qualified name cannot be resolved an empty list is returned.
            </remarks>
            <param name="source">The context source.</param>
            <param name="fullyQualifiedName">The qualified name to resolve on the source (leave empty
            to get the context source as a number).</param>
            <returns>A list of numbers matching the source path.</returns>
            <exception cref="T:System.FormatException">In case a source value could not be converted to a number.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetValueAsDates(Tridion.ContentManager.Templating.ISource,System.String)">
            <summary>
            Utility function to access a source as list of DateTimes.
            </summary>
            <remarks>
            If the fully qualified name cannot be resolved an empty list is returned.
            </remarks>
            <param name="source">The context source.</param>
            <param name="fullyQualifiedName">The qualified name to resolve on the source (leave empty
            to get the context source as a date).</param>
            <returns>A list of dates matching the source path.</returns>
            <exception cref="T:System.FormatException">In case a source value could not be converted to a date.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetValueAsTcmUris(Tridion.ContentManager.Templating.ISource,System.String)">
            <summary>
            Utility function to access a source as list of TcmUris.
            </summary>
            <remarks>
            If the fully qualified name cannot be resolved an empty list is returned.
            </remarks>
            <param name="source">The context source.</param>
            <param name="fullyQualifiedName">The qualified name to resolve on the source (leave empty
            to get the context source as an uri).</param>
            <returns>A list of tcm uris matching the source path.</returns>
            <exception cref="T:System.FormatException">In case a source value could not be converted to a tcm uri.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetContentTypes(Tridion.ContentManager.Templating.ISource,System.String)">
            <summary>
            Determine a list of content-types for a certain source expression relative to
            a source.
            </summary>
            <param name="source">The source that acts as context for this evaluation.</param>
            <param name="partiallyQualifiedPath">The source expression to resolve.</param>
            <returns>A list of found content types. If the expression could not be resolved,
            the list is empty. There can be multiple entries if there are multiple matching sources, 
            usually these will all have the same content type.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.CreateSourceListForString(System.String)">
            <summary>
            Utility function to build a source-list for a string-value.
            </summary>
            <param name="value">The value to create the source for.</param>
            <returns>A new list with a single <c>StringSource</c> representing the value.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.CreateSourceList(Tridion.ContentManager.Templating.ISource)">
            <summary>
            Utility function to build a source-list based on a single source.
            This can be used e.g. to create a source based on the current value.
            </summary>
            <param name="source">The source to create a list for.</param>
            <returns>A new list with the source-parameter as single entry.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetValueFromGetSources(Tridion.ContentManager.Templating.ISource,System.String)">
            <summary>
            Utility function to allow easy implementation of the <c>GetValue</c> method
            in <c>ISource</c> implementing classes, if GetSources is fully implemented in that class.
            </summary>
            <param name="source">The source object that calls this method.</param>
            <param name="fullyQualifiedName">The fully qualified name to determine the
            <c>GetValue</c> result for. The full qualified name may not be the empty string, as that
            might lead to unending recursion (because this routine will call <c>GetValue("")</c> on a subsource, 
            which could be this source again).</param>
            <returns>The value of <c>source.GetSources(fullyQualifiedName).GetValue("")</c>, possibly concatenated
            with ',' if it is multi-value.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetStringValue(Tridion.ContentManager.Templating.ISource,System.String,System.Boolean,System.Boolean,Tridion.ContentManager.Templating.ContentType@)">
            <summary>
            Utility function to get the string value from a (set of) source(s).
            </summary>
            <param name="source">The source object that calls this method.</param>
            <param name="fullyQualifiedName">The fully qualified name to determine the
            <c>GetValue</c> result for.</param>
            <param name="htmlEncode">Whether or not the result is to be inserted as HTML, any non
            HTML characters are escaped.</param>
            <param name="resolveHtmlAsRtfContent">Whether or not resolveXhtml should be called on HTML fields</param>
            <param name="contentType">Type of the value</param>
            <returns>The value of source.GetSources(fullyQualifiedName).GetValue(""), possibly concatenated
            with ',' if it is multi-value.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.EvaluateSubSources(System.Collections.Generic.IList{Tridion.ContentManager.Templating.ISource},System.String)">
            <summary>
            Utility function for use in <see cref="M:Tridion.ContentManager.Templating.ISource.GetSources(System.String)"/> implementations, based on 
            a set of results on the current level, get further subsources if a further sub-path is specified.
            </summary>
            <param name="results">The list of sources representing the result at this level</param>
            <param name="subQualifiedName">The further path to resolve</param>
            <returns>The input result in case a subQualified name is not specified, otherwise
            a list with all results if the path is processed further.</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.SourceUtilities.GetValueAsTypeConverter`1">
            <summary>
            Generics utility class for GetValueAsType functions.
            </summary>
            <typeparam name="T">The type to convert to</typeparam>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetValueAsTypeConverter`1.#ctor(Tridion.ContentManager.Templating.SourceUtilities.ConvertSourceValue)">
            <summary>
            Constructor
            </summary>
            <param name="convertFunction">This delegate implementation must produce
            an object of type T</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.SourceUtilities.GetValueAsTypeConverter`1.GetValuesAsType(Tridion.ContentManager.Templating.ISource,System.String)">
            <summary>
            Utility function to access a source as list of basic items of a certain type.
            </summary>
            <remarks>
            If the fully qualified name cannot be resolved an empty list is returned.
            </remarks>
            <param name="source">The context source</param>
            <param name="fullyQualifiedName">The qualified name to resolve on the source (leave empty
            to get the context source as a value of type T)</param>
            <returns>A list of items matching the source path</returns>
            <exception cref="T:System.FormatException">In case a source value could not be converted to a number</exception>
        </member>
        <member name="T:Tridion.ContentManager.Templating.SourceUtilities.ConvertSourceValue">
            <summary>
            Delegate used in GetValueAsTypeConverter
            </summary>
            <param name="value">The value to convert</param>
            <returns>Must return a value of the expected type</returns>
            <exception cref="T:System.FormatException">In case the value cannot be converted, must throw this exception</exception>
        </member>
        <member name="T:Tridion.ContentManager.Templating.StringSource">
            <summary>
            Implementation of ISource interface for a single string-value.
            a string source is meant to represent an atomic string, and thus
            will only provide a match if an empty string is used for the name.
            
            Also contains utility functions for other Source implementations.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.StringSource.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="value">The value the source represents</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.StringSource.#ctor(System.String,Tridion.ContentManager.Templating.ContentType)">
            <summary>
            Constructor.
            </summary>
            <param name="value">The value the source represents</param>
            <param name="originalContentType">The optional content type of this item</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.StringSource.GetValue(System.String)">
            <summary>
            Determine the string value for a source.
            </summary>
            <param name="fullyQualifiedName">The name to get the source for</param>
            <returns>The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.StringSource.GetContentType">
            <summary>
            The content type of this source
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.StringSource.GetSources(System.String)">
            <summary>
            Retrieve the (list of) subsource(s) of a source. The returned subsource(s)
            can be used again to drill down the expression further.
            
            For example, if calling GetValue("Component.Schema.ID") on a source
            would return a value, calling
            	GetSources("Component.Schema")[0].GetValue("ID")
            would result in the same.
            </summary>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of subsources that match the partially qualified name. Most implementations
            of this method will not return all possible matches, but just the list of sources of the first
            match found.</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.ITcdlTag">
            <exclude/>
            <summary>
            Representation of a TCDL-tag for the TcdlParser.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ITcdlTag.GetAttribute(System.String)">
            <summary>
            Returns the value for the attribute or an empty string if the attribute does not exist
            </summary>
            <param name="name">name of the attribute</param>
            <returns>value of the attribute or an empty string if the attribute does not exist</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ITcdlTag.GetAttributeAsTcmUri(System.String)">
            <summary>
            Return a valid tcm uri for the attribute. When the attribute is empty or non-existing, a null TcmUri is returned
            </summary>
            <param name="name">name of the attribute</param>
            <returns>valid uri for the attribute</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">If the attribute has a value but is not a valid uri</exception>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ITcdlTag.Name">
            <summary>
            Name of the TcdlTag
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ITcdlTag.Attributes">
            <summary>
            Attributes for the tag
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ITcdlTag.InnerText">
            <summary>
            Returns the text contents for the tcdl tag. Excluding the tags itself. This property may also be used to change
            the tcdl tag contents without touching the surrounding tags itself, but only if Editable is true. 
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ITcdlTag.Text">
            <summary>
            Returns the text for the tag, including the tags itself. This property may also be used to change the tcdl tag
            in the document it resides, but only if Editable is true. Setting this property will not cause the InnerText property is
            to be updated.
            </summary>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">When attempting to set this property, while Editable is false</exception>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ITcdlTag.Editable">
            <summary>
            Returns true when the Text of this tcdl tag may be changed
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ITcdlTag.Parent">
            <summary>
            Returns the parent of this tag, if any. The parent will not be Editable
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TcdlTags">
            <exclude/>
            <summary>
            List of string-constants with the names of TCDL element and attribute names.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.TcdlNamespace">
            <summary>
            Namespace for tcdl
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentPresentation">
            <summary>
            TCDL tag element name for a component presentation.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentPresentationAttributeTemplate">
            <summary>
            'templateURI' attribute of 'ComponentPresentation' tag.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentPresentationAttributeComponent">
            <summary>
            'componentURI' attribute of 'ComponentPresentation' tag.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentPresentationAttributeType">
            <summary>
            'type' attribute of 'ComponentPresentation' tag.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentField">
            <summary>
            TCDL tag element name (only used within templating) for a component field.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentFieldAttributeName">
            <summary>
            'name' attribute of 'ComponentField' tag.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentFieldAttributeIndex">
            <summary>
            'index' attribute of 'ComponentField' tag.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentFieldAttributeTag">
            <summary>
            'tag' attribute of 'ComponentField' tag.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.ComponentFieldAttributeEdit">
            <summary>
            'edit' attribute of 'ComponentField' tag.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.FieldMarker">
            <summary>
            TCDL tag element name (only used within templating) for field start/end marker.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlTags.FieldValueMarker">
            <summary>
            TCDL tag element name (only used within templating) for field value start/end marker.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TcdlParser">
            <exclude/>
            <summary>
            Helps processing items with TCDL tags. Xml documents will be treated as text, so if both xml and text needs
            to be supported ensure that any changes made still result in valid xml
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TcdlParser.ComponentPresentationTagFilter">
            <summary>
            Filter that filters out only tcdl:ComponentPresentation tags
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TcdlParser.#ctor">
            <summary>
            Creates a TcdlParser that will process all tcdl: tags in a text document or Item
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TcdlParser.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a TcdlParser that will process the specified tags in a text document or Item
            </summary>
            <param name="tagFilter"></param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TcdlParser.Process(Tridion.ContentManager.Templating.Item,Tridion.ContentManager.Templating.TcdlParser.TagHandler)">
            <summary>
            Scans the given item for tcdl tags and allows the given TagHandler to process each one of them.
            Tags that are looked for depend on the selected filter at construction time.
            Items that contain xml will be treated as text, and afterwards converted back into xml if modifications
            were made. If xml items are expected, implementation of the TagHandler must ensure itself that any modifications
            will not render the xml invalid.
            </summary>
            <param name="item">Item to process</param>
            <param name="tagHandler">Handler that will is called for each tag encountered</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TcdlParser.ProcessText(System.String,Tridion.ContentManager.Templating.TcdlParser.TagHandler)">
            <summary>
            Scans the given string for tcdl tags and allows the given TagHandler to process each one of them.
            Tags that are looked for depend on the selected filter at construction time.
            </summary>
            <param name="text">text to process</param>
            <param name="tagHandler">Handler that will is called for each tag encountered</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TcdlParser.ProcessText(System.String,Tridion.ContentManager.Templating.TcdlParser.TagHandler,System.Boolean@)">
            <summary>
            Scans the given string for tcdl tags and allows the given TagHandler to process each one of them.
            Tags that are looked for depend on the selected filter at construction time.
            </summary>
            <param name="text">text to process</param>
            <param name="tagHandler">Handler that will is called for each tag encountered</param>
            <param name="wasModified">Ouput parameter indicating that at least one change was made by the TagHandler</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TcdlParser.ParseRawAttributeString(System.String)">
            <summary>
            Static helper method that will parse a set of xml style attributes from a string, using double or single quotes for attribute values.
            Attributes values are not xml un-escaped
            </summary>
            <param name="attributes">raw atrtibute string to be parsed, in the form of : attr="value" attr2="value"</param>
            <returns>key-value collection representing the attributes</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TcdlParser.TagHandler">
            <exclude/>
            <summary>
            Implement this delegate to be able to perform processing on a TCDL tag during processing.
            </summary>
            <param name="tag">The TCDL tag to process</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplateInvocation">
            <summary>
            This class models a template invocation, including parameters to be passed to the template.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateInvocation.#ctor(Tridion.ContentManager.TcmUri,System.String)">
            <summary>
            Creates a TemplateInvocation object based on the given URI and title. The newly created
            invocation object doesn't have any parameters.
            </summary>
            <param name="templateUri">The TcmUri of the template to invoke.</param>
            <param name="templateTitle">The title/name of the template to invoke.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateInvocation.#ctor(System.Xml.XmlElement)">
            <summary>
            Creates a new TemplateInvocation object based on the XML in the given rootNode, with the 
            namespaces handled by the given resolver.
            </summary>
            <param name="rootNode">The root node of the XML from which to construct the object.</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateInvocation.TemplateUri">
            <summary>
            The URI of the template that is to be invoked.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateInvocation.TemplateTitle">
            <summary>
             The title of the template that is to be invoked.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateInvocation.ParameterXml">
            <summary>
            The root element of the parameter XML (can be null if there are no parameters)
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.ContentType">
            <summary>
            Container for a Mime type, as used to determine the content-type of items in a package.
            </summary>
            <remarks>
            <para>
            Although this is a general class, it is mostly used for package items (see <see cref="P:Tridion.ContentManager.Templating.Item.ContentType"/>).
            </para>
            <para>
            It is possible to create your own content type or use one of the predefined constant ones.
            </para>
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Unknown">
            <summary>
            Content type 'application/unknown'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Text">
            <summary>
            Content type 'text/plain'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Xml">
            <summary>
            Content type 'text/xml'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Xhtml">
            <summary>
            Content type 'text/xhtml'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Html">
            <summary>
            Content type 'text/html'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Jpeg">
            <summary>
            Content type 'image/jpeg'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Gif">
            <summary>
            Content type 'image/gif'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Png">
            <summary>
            Content type 'image/png'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Bmp">
            <summary>
            Content type 'image/bmp'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.XBmp">
            <summary>
            Content type 'image/x-bmp'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Page">
            <summary>
            Content type 'tridion/page'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Component">
            <summary>
            Content type 'tridion/component'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Schema">
            <summary>
            Content type 'tridion/schema'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Publication">
            <summary>
            Content type 'tridion/publication'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Template">
            <summary>
            Content type 'tridion/template'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.ComponentArray">
            <summary>
            Content type 'tridion/component[]'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.ComponentPresentationArray">
            <summary>
            Content type 'tridion/componentpresentation[]'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.StringArray">
            <summary>
            Content type 'tridion/string[]'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.String">
            <summary>
            Content type 'tridion/string'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.ItemField">
            <summary>
            Content type 'tridion/field'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.ExternalLink">
            <summary>
            Content type 'tridion/externallink'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.ItemLink">
            <summary>
            Content type 'tridion/itemlink'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.Number">
            <summary>
            Content type 'text/number'
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.ContentType.DateTime">
            <summary>
            Content type 'text/date'
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ContentType.RepresentsHtml(Tridion.ContentManager.Templating.ContentType)">
            <summary>
            Determine whether this content type is in the HTML family.
            </summary>
            <remarks>This method should only be used to check whether the content should be encoded.</remarks>
            <param name="contentType">The content type to check</param>
            <returns>Whether this content type can be considered HTML (for encoding purposes)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ContentType.#ctor(System.String)">
            <summary>
            Constructor for a content type object.
            </summary>
            <param name="value">A MIME-type string (any string with a '/' in it is accepted).</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ContentType.Matches(Tridion.ContentManager.Templating.ContentType)">
            <summary>
            Determine whether two content-types are equal, taking into account wildcards (so content
            type '*/*' matches always).
            </summary>
            <param name="contentType">The contenttype object to match with.</param>
            <returns>True if the contentTypes are considered the same in a match, false otherwise.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ContentType.Equals(System.Object)">
            <summary>
            Implementation of <c>Equals</c>, in case ContentType objects are used
            in comparison.
            </summary>
            <param name="obj">The contenttype object to perform the equals on.</param>
            <returns>Whether the argument object is equal to this object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ContentType.GetHashCode">
            <summary>
            Implementation of <c>GetHashCode</c>, in case ContentType objects are used
            in dictionaries.
            </summary>
            <returns>A hashcode for this object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.ContentType.ToString">
            <summary>
            Implementation of <c>ToString</c>, assuming that ContentType objects display 
            meaningful information in debug output.
            </summary>
            <returns>A string representation of this content type.</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.ContentType.Value">
            <summary>
            The text-value of this content type.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator">
            <summary>
            This class interprets a Dreamweaver template and merges it with the content.
            </summary>
            <remarks>
            Article on Dreamweaver templates (http://www.adobe.com/devnet/dreamweaver/articles/dw_templates.html)
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.Configure(Tridion.ContentManager.Templating.Configuration.MediatorElement)">
            <summary>
            Configure the mediator
            </summary>
            <param name="configuration">The configuration element for this mediator</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of IMediator, execute the transformation of a Dreamweaver template
            </summary>
            <param name="engine">The context engine</param>
            <param name="templateToTransform">The template to execute</param>
            <param name="package">The package to operate on</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.SelectRegionToTransform(System.String,System.String)">
            <summary>
            Recursive method to find a repeating region with a given name.
            The first matching region found is returned.
            </summary>
            <param name="templateSelection">The template text to look in</param>
            <param name="selectedRepeatingRegionName">The name the repeating region to find should have</param>
            <returns>The content of the found repeating region, or null if no repeating region was found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.TransformRegions(Tridion.ContentManager.Templating.Package,System.String)">
            <summary>
            Recursive method that processes one level of Dreamweaver template tags.
            It looks for:
             - Repeatable regions
             - Optional regions
             - value expressions (${...}), @@...@@, <!-- TemplateExpr expr="..." -->
            In case of optional repeatable regions, each entry is processed recursively. This ensures
            regions within regions are evaluated.
            </summary>
            <param name="package">Reference to package to resolve data on</param>
            <param name="dreamweaverTemplate">The template string to process. This may be a partial template</param>
            <returns>The transformed template string, in which the aforementioned items will have been resolved
            (replaced in the string by their actual value)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.TransformRepeatingRegions(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.StringReference)">
            <summary>
            Helper routine for Transform method to handle repeating regions, see TransformRegions
            method for further details
            </summary>
            <param name="package">Reference to package to resolve data on</param>
            <param name="templateReference">string container containing the template to process. The underlying
            string is changed in place</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.TransformOptionalRegions(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.StringReference)">
            <summary>
            Helper routine for Transform method to handle optional regions, see TransformRegions 
            method for further details
            </summary>
            <param name="package">Reference to package to resolve data on</param>
            <param name="templateReference">string container containing the template to process. The underlying
            string is changed in place</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.TransformValueReferences(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.StringReference,System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Helper routine for Transform method to handle expression replacements, see TransformRegions 
            method for further details
            </summary>
            <param name="package">Reference to package to resolve data on</param>
            <param name="templateReference">string container containing the template to process. The underlying
            string is changed in place</param>
            <param name="startTagExpression">The start regular expression to find</param>
            <param name="endTag">The end expression to find</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.RemoveTemplateParameters(Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.StringReference)">
            <summary>
            Helper routine for Transform method to handle the removal of TemplateParam references
            </summary>
            <param name="templateReference">string container containing the template to process. The underlying
            string is changed in place</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.FindMatchingEndIndex(System.String,System.Int32,System.String,System.String)">
            <summary>
            Find an matching endTag for a start-tag, taking into account nesting.
            The startPosition will point to a startTag in the text, the matching endTag
            should take into account nesting. So e.g. in the case
            	start
            		start
            		end
            	end
            	end
            This routine should find the second end.
            In case a matching tag cannot be found, -1 is returned.
            </summary>
            <param name="text">The text to match the tags in</param>
            <param name="startPosition">The position to start the evaluation, will always point
            at the start tag</param>
            <param name="startTag">The string contents of a start-tag to use in matching</param>
            <param name="endTag">The string contents of an end-tag to use in matching</param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.GetRepeatingItems(Tridion.ContentManager.Templating.Package,System.String)">
            <summary>
            Attempt to create a list of items based on the region name of a repeating region.
            The list of items can be:
             1. A list of component(presentation)s, based on an item in the package that
            represents such a list.
             2. A (list of) string-value(s) as taken from the package.
             3. If none of the two above match, currently the repeating group falls back to
            the components on the page (which must be in the package).
            </summary>
            <param name="package">The package to look for information in</param>
            <param name="regionNameExpr">The string name of the repeating region, used to look
            up items/ sources in the package</param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.CreateComponentItem(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.Templating.ComponentPresentation)">
            <summary>
            Construct a package item based on a component presentation object (an item of content
            type component is created, with a template uri property set if available).
            </summary>
            <param name="package">The package to create the item on</param>
            <param name="componentPresentation">The object to create the item for</param>
            <returns>The newly created item (that was not yet added to the package)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.RegisterTemplateBinaries(Tridion.ContentManager.Templating.Package,System.String,System.String)">
            <summary>
            Register the binaries found in the template. Also alter the template so that
            it contains the converted strings).
            </summary>
            <param name="package">The context package</param>
            <param name="baseItemTcmUri">The URI of the items where URLs should be relative to</param>
            <param name="templateString">The HTML content to transform</param>
            <returns>The converted HTML, with the result of PublishBinary as URL strings instead
            of the original.
            A side effect is that PublishBinary has been called for all found binaries</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.StringReference">
            <summary>
            Internal data structure (not a struct because we don't
            want copies here) to work around string being an immutable object, so
            that strings can be exchanged between methods and still be altered.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Dreamweaver.DreamweaverMediator.StringReference.Value">
            <summary>
            Reference to the underlying value
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Expression.JScriptEvaluator">
            <exclude/>
            <summary>
            JScript Evaluator class to evaluate JScript expressions.
            (c) 2004 Scott Allen, http://www.odetocode.com/Code/80.aspx
            With several modifications to integrate with ExpressionEvaluator
            
            Notes:
             - This class requires a reference to the 
            		Microsoft.JScript 
            		Microsoft.Vsa    (for the exception handling) 
               modules.
             - The various Evaluate... methods may throw a TemplatingException, this needs
            to be caught and processed by the caller of these methods.
             - The statement to execute may no longer contain any variable reference, so
            must be a simple constant expression.
             - In theory the expression may be complex and contain e.g. function
            declarations and for-loops, in practice these are not supported.
            
            This class (or rather the class it references) is unsafe. Look for unsafe in the 
            JScript code below, and see http://www.dotnet247.com/247reference/msgs/33/166206.aspx for details.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Expression.JScriptEvaluator.classTemplate">
            <summary>
            Template for the dynamically built JScript class that is accessed via a template, eg via Dreamweaver expression
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.JScriptEvaluator.BuildJScriptSource(System.Collections.Generic.IList{System.Type})">
            <summary>
            Builds the Jscript source from the list of functions passed to it.
            </summary>
            <remarks>
            Builds two strings which are used to fill in the place holders {0} and {1} in the 'classTemplate' string defined above
            </remarks>
            <param name="functionSources">The function sources.</param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.JScriptEvaluator.GenerateJScriptMethods(System.Int32,System.Type,System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Generates the source block.
            </summary>
            <param name="sourceBlockIndex">Index of the source block.</param>
            <param name="functionSource">The function source.</param>
            <param name="jscriptMethodNames">The names jscript methods already generated.</param>
            <returns></returns>
            <example>
            public function RenderComponentPresentation() : String
            {
            return expressionContext1.RenderComponentPresentation(null, null);
            }
            ...
            </example>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.JScriptEvaluator.#ctor(Tridion.ContentManager.Templating.Package)">
            <summary>
            Initializes a new instance of the <see cref="T:Tridion.ContentManager.Templating.Expression.JScriptEvaluator"/> class. 
            Constructor
            </summary>
            <param name="package">
            The Package.
            </param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.JScriptEvaluator.EvaluateToBool(System.String)">
            <summary>
            Evaluate a JScript expression, where the expected result is a boolean.
            (See the class introduction for limitations on the statements and other
            information)
            </summary>
            <param name="statement">The JScript statement to execute.</param>
            <returns>True if the expression evaluates to true, false in *all* other
            cases</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the script could not be executed</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.JScriptEvaluator.EvaluateToString(System.String)">
            <summary>
            Evaluate a JScript expression, where the expected result is a string.
            (See the class introduction for limitations on the statements and other
            information)
            </summary>
            <param name="statement">The JScript statement to execute.</param>
            <returns>The string-value of the result of the expression</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the script could not be executed</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Expression.JScriptEvaluator.EvaluateToObject(System.String)">
            <summary>
            Evaluate a JScript expression, and return an object containing the result
            At the moment, the result is always treated as a string.
            (See the class introduction for limitations on the statements and other
            information)
            </summary>
            <param name="statement">The JScript statement to execute.</param>
            <returns>The return value of the statement evaluation</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the script could not be executed</exception>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Item">
            <summary>
            Representation of a single item in a publishing <see cref="T:Tridion.ContentManager.Templating.Package"/>.
            </summary>
            <remarks>
            <para>
            There are various <c>Create...</c> methods in the <see cref="T:Tridion.ContentManager.Templating.Package"/> class to create <c>Item</c> objects.
            </para>
            <para>
            The item can be based on a
            Tridion object, but can also represent a separate data item.</para>
            <para>The item's value can be accessed as:
            <list type="bullet">
            	<item>A string</item>
            	<item>A stream</item>
            	<item>An XmlDocument</item>
            </list>
            (and an ISource).
            </para>
            <para>
            The following properties identify an Item:
            <list type="bullet">
            	<item>The type of value (<see cref="P:Tridion.ContentManager.Templating.Item.Type"/>).</item>
            	<item>Their actual value (depending on the package-item-type, although 
            methods exist to get the value in another form).</item>
            	<item>The content type of the item (<see cref="P:Tridion.ContentManager.Templating.Item.ContentType"/>), indicating what kind of
            content the item represents.</item>
            	<item>A set of named properties (<see cref="P:Tridion.ContentManager.Templating.Item.Properties"/>) to specify further information of the item.</item>
            	<item>If the item is stored in a package, it can have a name (see e.g. <see cref="M:Tridion.ContentManager.Templating.Package.GetByName(System.String)"/>).</item>
            </list>
            </para>
            <para>
            See the <a href="/Overview/Templating concepts/Package.html">overview</a> documentation
            for some more information.
            </para>
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyTcmUri">
            <summary>
            'TCMURI' property name.
            The URI of the tridion object the item represents (e.g. used in multimedia binaries)
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyTemplateUri">
            <summary>
            'TemplateURI' property name.
            The template URI, e.g. used to set the template an Item should be transformed with
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyFieldSourcePath">
            <summary>
            'FieldPath' property name.
            If set, the Item aims to represent only a subselection of the Tridion object in the item
            (like a specific component-field). This property indicates a 'source-path' within the item
            to the relevant data
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyTargetStructureGroup">
            <summary>
            'TargetStructureGroup' property name.
            The optional structure group to publish to on a publishing action
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyPublishedPath">
            <summary>
            'PublishedPath' property name.
            The path under which a binary was published (set only once, based on the various filename properties)
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyFileName">
            <summary>
            'FileName' property name.
            The base filename to use for a published binary
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyFileNamePrefix">
            <summary>
            'FileNamePrefix' property name.
            The optional prefix to append to the start of the filename on a publishing action
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyFileNameSuffix">
            <summary>
            'FileNameSuffix' property name.
            The optional suffix to append to the end of the filename (before the extension) on a publishing action
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyFileNameExtension">
            <summary>
            'FileNameExtension' property name.
            The optional extension that overrides the extension set on the file
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Item.ItemPropertyBaseTcmUri">
            <summary>
            'BaseTCMURI' property name.
            The URI of the base URL for this item (used only in ExtractBinariesFromHtmlTemplate)
            (special property because e.g. Template URI can be many different URIs)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.#ctor(Tridion.ContentManager.Templating.ContentType,Tridion.ContentManager.Templating.Engine)">
            <summary>
            Base constructor to construct a new empty item.
            </summary>
            <param name="contentType">The content-type of the item</param>
            <param name="engine">The context engine</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetAsString">
            <summary>
            Get the value of this item as a string.
            </summary>
            <returns>The value of the item as a string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.SetAsString(System.String)">
            <summary>
            Set the value of this item as a string
            </summary>
            <param name="value">The string-value of the item</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.AppendToStringValue(System.String)">
            <summary>
            Utility method to append some text to the existing string-value
            </summary>
            <param name="textToAppend">The extra text</param>
            <returns>The new text-value of the item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetAsStream">
            <summary>
            Get the value of the item as a stream.
            </summary>
            <remarks>
            The value is a copy, and should not be altered.
            </remarks>
            <returns>The item value as a stream</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.SetAsStream(System.IO.Stream)">
            <summary>
            Set the value of this item based on this stream (the stream is
            read for this).
            </summary>
            <param name="inputStream">The stream representing the new value of the item</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetAsXmlDocument">
            <summary>
            Get the value of the item as an XML document.
            </summary>
            <remarks>
            If you alter the XML document retrieved by <see cref="M:Tridion.ContentManager.Templating.Item.GetAsXmlDocument"/>, you must
            call <see cref="M:Tridion.ContentManager.Templating.Item.SetAsXmlDocument(System.Xml.XmlDocument)"/> to reflect the changes.
            </remarks>
            <returns>The value of the item as an XML document</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.SetAsXmlDocument(System.Xml.XmlDocument)">
            <summary>
            Set the value of an item to an XML document.
            </summary>
            <remarks>
            If you alter the XML document retrieved by <see cref="M:Tridion.ContentManager.Templating.Item.GetAsXmlDocument"/>, you must
            call <see cref="M:Tridion.ContentManager.Templating.Item.SetAsXmlDocument(System.Xml.XmlDocument)"/> to reflect the changes.
            </remarks>
            <param name="value">The new value for the item</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetAsSource">
            <summary>
            Get this item as a source.
            </summary>
            <returns>A source representing the item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.SetCachedTridionItem(Tridion.ContentManager.IdentifiableObject)">
            <summary>
            Internal method to update the cached tridion item explicitly, to
            update performance.
            </summary>
            <remarks>
            Call this method after the other setters on the item have been called,
            as they may clear the cached item.
            </remarks>
            <param name="tridionItem">The tridion item this item does represent</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.ResetValue">
            <summary>
            Utility method used in the property-setters to clear the value of an item
            just before it is set with a new value.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.CopyStream(System.IO.Stream)">
            <summary>
            Utility method to make a copy of an input-stream where the target
            is in memory so it can be accessed multiple times.
            </summary>
            <param name="inputStream">The stream to make the copy of</param>
            <returns>A copy of the stream as a byte array</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetSources(System.String)">
            <summary>
            <see cref="T:Tridion.ContentManager.Templating.ISource"/> implementation.
            Retrieve a (list of) subsource(s) of a source.
            </summary>
            <remarks>
            <para>
            For example, when calling 
            	<code>GetSources("Schema")[0].GetValue("ID")</code>
            on an item representing a component, the schema id would be returned.
            </para>
            <para>
            For non-Tridion object based items, only the string value (source expression <c>''</c>) and
            properties (source expression <c>'Properties.&lt;PropertyName&gt;'</c>) result in a value.
            For tridion items, more of the value is exposed.
            </para>
            </remarks>
            <param name="partiallyQualifiedName">The source expression to resolve</param>
            <returns>A list of subsources that match the partially qualified name.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetValue(System.String)">
            <summary>
            <see cref="T:Tridion.ContentManager.Templating.ISource"/> implementation.
            Determine the string value for a source expression.
            </summary>
            <remarks>
            <para>
            For example, for input <c>Schema.ID</c>
            the result could be the schema URI of this component-item, if this item 
            represents a Tridion component.
            </para>
            <para>
            For non-Tridion object based items, only the string value (source expression <c>''</c>) and
            properties (source expression <c>'Properties.&lt;PropertyName&gt;'</c>) result in a value.
            For tridion items, more of the value is exposed.
            </para>
            </remarks>
            <param name="fullyQualifiedName">The source expression to determine the value for</param>
            <returns>The value found, or null if no value was found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetContentType">
            <summary>
            <see cref="T:Tridion.ContentManager.Templating.ISource"/> implementation.
            Get the content type property of this item.
            </summary>
            <returns>The content type of this item.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetAsTridionObjectSource">
            <summary>
            Utility function, only meant to be used from GetValue and GetSource.
            Try to create a TridionObjectSource of an item.
            </summary>
            <returns>The TridionObjectSource representation of the item, or null
            if e.g. this item does not represent a Tridion item.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.HasParseableTridionContentType">
            <summary>
            Perform some checking on the content type, to determine whether this item is supposed
            to contain the data of a Tridion item.
            </summary>
            <returns>true if this Item represents a Tridion item or not</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.Equals(System.Object)">
            <summary>
            Override of <see cref="M:System.Object.Equals(System.Object)"/> so items can be compared and placed in collections.
            </summary>
            <param name="obj">The object to compare with</param>
            <returns>Whether the items are equal</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.EqualByteArrays(System.Byte[],System.Byte[])">
            <summary>
            Compare two byte arrays for equality.
            </summary>
            <param name="array1">The first byte array to compare</param>
            <param name="array2">The second byte array to compare</param>
            <returns>true in case the arrays are equal, false otherwise</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetHashCode">
            <summary>
            Override of <see cref="M:System.Object.GetHashCode"/> so items can be compared and placed in collections.
            </summary>
            <returns>A hash-code for this item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.ConstructFileName">
            <summary>
            Construct a filename for this item.
            </summary>
            <remarks>Based on the properties of the item. The filename property must be set, but
            there can be other aspects set on the item that are taken into account in the filename</remarks>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Item.GetPropertyValue(System.String)">
            <summary>
            Get a property value from an item, or an empty string if the property value
            is missing or null.
            </summary>
            <remarks>Simple helper for ConstructFileName, to access item property values</remarks>
            <param name="propertyName">The name of the property to retrieve</param>
            <returns>The property value, or an empty string if the property is missing or null</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Item.ContentType">
            <summary>
            The content type of this item.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Item.Type">
            <summary>
            The item-type (String, Stream or Xml document) of this item.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Item.Properties">
            <summary>
            The properties associated with this item. The item properties are key-value pairs
            with extra information of the item.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ActivateTrackingTemplate">
            <summary>
            Transforms the default output item to add tcdl:IncrementTrackingKey tags for component presentations that require it.
            This template must run before TargetGroups are applied (or in general before any conditional code is added to 
            a component presentation), so that tcdl:IncrementTrackingKey will be executed unconditionally
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ActivateTrackingTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Transformation implementation as defined by ITemplate 
            </summary>
            <param name="engine">The engine can be used to retrieve additional information or execute additional actions.</param>
            <param name="package">The package provides the primary data for the template.</param>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">If tcdl:TargetGroup tags are encountered in the default output item</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ActivateTrackingTemplate.ProcessComponentPresentation(Tridion.ContentManager.Templating.ITcdlTag)">
            <summary>
            Injects tcdl:IncrementTrackingKey tags when there are keywords to track for the given component presentation
            This is an implementation of ComponentPresentationProcessor.TextHandler
            </summary>
            <param name="tag">TcdlTag for this occurence of a ComponentPresentation</param>
            <returns>when there a keywords to track, this returns the new component presentation including IncrementTrackingKey tags, otherwise null indicating the CP can remain unchanged</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ActivateTrackingTemplate.ValidateInput(Tridion.ContentManager.Templating.Item)">
            <summary>
            Ensures that no tcdl:TargetGroup tags are already present as these would disturb the adding of tcdl:IncrementTrackingKey calls
            </summary>
            <param name="outputItem">Item to test for target group tags</param>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">If tcdl:TargetGroup tags are encountered</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ActivateTrackingTemplate.DetermineKeywordsToTrack(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri)">
            <summary>
            Returns a list of keywords that need to be tracked. 
            </summary>
            <param name="componentUri">Uri of the component that possibly uses tracked categories</param>
            <param name="templateUri">Uri of the template that defines the categories that are tracked</param>
            <returns>a list of keywords that need to be tracked</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.CleanupTemplate">
            <summary>
            Removes any artificats of the template process from the output item
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.CleanupTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Transform as defined by ITemplate. Removes all templating added artificats from the output item.
            </summary>
            <param name="engine">Templating engine</param>
            <param name="package">Package to process</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ConvertXmlToHtmlTemplate">
            <summary>
            Template to perform a Xml to Html conversion through a Xslt transformation 
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ConvertXmlToHtmlTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of ITemplate interface.
            </summary>
            <param name="engine">The engine used as context for the transformation</param>
            <param name="package">The package serving as in- and output for the transformation.</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ExtractComponentsFromRegionsTemplate">
            <summary>
            This template gets the page from the package, iterates over all its regions recursively, and adds a ComponentPresentation item for each component presentation in the regions.
            The Component Presentations are grouped in separate package items with names derived from the region name they belong to.
            It also adds a PageRegions item, which is a list of all region names.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractComponentsFromRegionsTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of ITemplate, to perform the template functionality
            </summary>
            <param name="engine">The context engine</param>
            <param name="package">The package to operate on</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates">
            <summary>
            Installation related class to create a set of default templates and their parameter
            schemas in a new folder in a publication. The templates created are the default templates
            in the Tridion.ContentManager.Templating, as specified in the default_templates_setup.xml 
            configuration resource.
            </summary>
            <remarks>
            The created templates are C# code fragment templates, with RunTemplate calls using tcm:0-0-0 as
            the referencing template.
            The exact usage of this class is not known at the time of writing. It should be run with a construct
            like:
            	new Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates(publicationUri).
            		ConstructDefaultTemplates(null, "Default 5.3 Templates");
            Preferably run when all assemblies are registered and the configuration is available.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.GetExistingOrNewItem``1(System.String)">
            <summary>
            Gets an existing or new item with a given type and title in checked-out state.
            </summary>
            <typeparam name="T">The type of the item to get.</typeparam>
            <param name="title">The title (case insensitive) of the item to get.</param>
            <returns>The existing item or <c>null</c> if no items with the given type and title exists.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.CreateDefaultTemplates(System.String,System.String)">
            <summary>
            Public API to set up the default templates in a folder with a default name ("Default Templates").
            </summary>
            <param name="userName">The name of the user to impersonate (null for no impersonation)</param>
            <param name="parentFolderUriString">The folder to create the new folder in</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.CreateDefaultTemplates(System.String,System.String,System.String)">
            <summary>
            Public API to set up the default templates in a folder with the specified name.
            </summary>
            <param name="userName">The name of the user to impersonate (null for no impersonation)</param>
            <param name="parentFolderUriString">The folder to create the new folder in</param>
            <param name="folderName">The name of the new folder to create</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.CreateDefaultTemplates(Tridion.ContentManager.Session,System.String,System.String)">
            <summary>
            Public API to set up the default templates in a folder with the specified name.
            </summary>
            <param name="session">The TOM.NET session to use</param>
            <param name="parentFolderUriString">The folder to create the new folder in</param>
            <param name="folderName">The name of the new folder to create</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.#ctor(Tridion.ContentManager.Session,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="session">The TOM.NET Session to use</param>
            <param name="publicationUri">The publication the templates should be stored in</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.SetupTemplates(System.String,System.String)">
            <summary>
            Main access method, create a new folder and store the default templates and parameter
            schemas in it.
            </summary>
            <param name="parentFolderUri">The parent folder where the new folder for the templates should be created
            (when null, the root-folder is used)</param>
            <param name="folderName">The name of the new folder to create</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.SetTargetFolder(System.String,System.String)">
            <summary>
            Create the target folder for construction of the new templates
            </summary>
            <param name="parentFolderUri">The parent folder where the new folder for the templates should be created
            (when null, the root-folder is used)</param>
            <param name="folderName">The name of the new folder to create</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.CreateOrUpdateTbbWithTextContents(System.String,Tridion.ContentManager.ContentManagement.Schema,System.String,System.String)">
            <summary>
            Create/update a TBB with the passed string-content, and a link to
            a parameter-schema if available.
            </summary>
            <param name="title">The name of the to create</param>
            <param name="parameterSchema">The (optional) parameter schema to set on the new template</param>
            <param name="content">The code that constitutes the new template</param>
            <param name="templateType">The type of template to be created</param>
            <returns>The newly created template</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.CreateOrUpdateCompoundTemplate(System.String,Tridion.ContentManager.ContentManagement.Schema,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create a Compound template TBB with the invocations URIs as basis for the content, and a link to
            a parameter-schema if available.
            </summary>
            <param name="title">The name of the to create</param>
            <param name="parameterSchema">The (optional) parameter schema to set on the new template</param>
            <param name="itemType">What kind of template to create, 'tbb', 'page', or 'component'</param>
            <param name="invocationUris">The URIs of the invocations that should make up the template</param>
            <returns>The newly created template</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Utility method to get an attribute value from an element, as a string
            </summary>
            <param name="node">The element-node to get the attribute from</param>
            <param name="attributeName">The name of the attribute</param>
            <returns>The attribute value, or null in case no attribute with the given
            name was found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.SetParameterDescriptions(Tridion.ContentManager.ContentManagement.Schema,System.String)">
            <summary>
            Sets parameter descriptions on the given parameters Schema by setting custom URLs on the schema fields.
            </summary>
            <param name="parametersSchema">The parameters Schema to set the custom URLs on.</param>
            <param name="helpFile">The HTML help file containing the parameter descriptions.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.CreateParametersSchema(System.String,System.String,System.String,System.String,Tridion.ContentManager.ContentManagement.Folder)">
            <summary>
            Creates a new parameters Schema in the given target Folder.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.UpdateParametersSchema(Tridion.ContentManager.ContentManagement.Schema,System.String)">
            <summary>
             Updates and saves a parameters Schema, checking out if necessary and checking back in after save (doneEditing)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SetupDefaultTemplates.SaveBinaryContent(System.Byte[],System.String,Tridion.ContentManager.CommunicationManagement.TemplateBuildingBlock)">
            <summary>
            Set new binary, content, and immediately save the template
            </summary>
            <remarks>
            The immediate saving is a side-effect from the temporary file being necessary
            in changing the content.
            </remarks>
            <param name="newValue">The new content</param>
            <param name="fileName">The filename to use for the binary</param>
            <param name="templateBuildingBlock"></param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.SiteEdit13Template">
            <summary>
            Acts as a Page and Component Template and will enable SiteEdit on those items.
            For Page templates based on Template configuration, ComponentPresentations are marked for SiteEdit and
            the SiteEdit initialization call is generated.
            For Component Templates, Component Fields are marked to enable them SiteEditing.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.ParameterTargetType">
            <summary>
            Required for both CT and PT, used to determine if siteedit is required for the target we are rendering for
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.ParameterHtmlTag">
            <summary>
            Optional for both CT and PT. For PT this dtermines the html tag used to mark CPs. Default "span"
            For CT this determines html tag to mark component fields. Note that the field marking may
            also indicate the tag to use, which has precedence over this value. Default is "span"
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Transform implementation, see ITemplate
            </summary>
            <param name="engine">engine to use for this Transform call</param>
            <param name="package">package to use for this Transform call</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.TagHandler(Tridion.ContentManager.Templating.ITcdlTag,System.Collections.Generic.ICollection{System.String})">
            <summary>
            
            </summary>
            <param name="tag"></param>
            <param name="newCompomentsTarget"></param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.ProcessComponentFieldTag(Tridion.ContentManager.Templating.ITcdlTag)">
            <summary>
            Processes a ComponentField tag that is encountered during CP rendering.
            Will only add site edit attributes if site edit is enabled 
            </summary>
            <param name="tag">ComponentField tag</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.ProcessComponentPresentationTag(Tridion.ContentManager.Templating.ITcdlTag)">
            <summary>
            Processes ComponentPresentation tags and adds site edit attributes where required
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.ProcessNewComponentTag(Tridion.ContentManager.Templating.ITcdlTag,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Processes the SiteEditNewComponentTag and adds the new component definition to the target collection.
            This is later added to the site edit initialization call
            </summary>
            <param name="tag"></param>
            <param name="newCompomentsTarget"></param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.DetermineXPathForField(Tridion.ContentManager.TcmUri,System.String,System.Boolean@)">
            <summary>
            Given a componentUri and a Qualified field name (in Templating terms, for example Metadata.Address.City) return the 
            XPath to it as required by SiteEdit.
            </summary>
            <param name="componentUri"></param>
            <param name="fieldName"></param>
            <param name="isMultiValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.FindItemFieldXPath(System.String[],System.Int32,Tridion.ContentManager.ContentManagement.Fields.ItemFields,System.Boolean@)">
            <summary>
            Locate (sub)field indicated by parts[currentIndex] in the given ItemFields collection, when found the XPath for
            this field is returned and isMultiValue will be set to true if the field supports multiple values.
            Returned is a XPath statement that can be used to resolve the field on the component xml and that 
            is suited for siteedit.
            </summary>
            <param name="parts"></param>
            <param name="currentIndex"></param>
            <param name="fields"></param>
            <param name="isMultiValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.IsSiteEditEnabledPublicationTarget(Tridion.ContentManager.TcmUri)">
            <summary>
            Returns true when the given uri is a target type uri that is part of the publication target currently
            being published to or when there is no complete publishing context and RenderMode is preview.
            </summary>
            <param name="selectedTargetTypeUri"></param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.GetTemplateParameter(System.String,System.String)">
            <summary>
            Returns a string value identified by the given name from the package or the given defaultValue if the
            package does not contain the named item.
            </summary>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.SiteEdit13Template.GetAttributeValue(System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Returns the value for attribute [name] or the [defaultValue] if there is no attribute by that name.
            </summary>
            <param name="attributes"></param>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.TargetGroupPersonalizationTemplate">
            <summary>
            Transforms the default output item by adding targetgroup conditions to any component presentation that is present on the page and has 
            some target groups defined.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.TargetGroupPersonalizationTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of the actual transformation as defined by ITemplate
            </summary>
            <param name="engine">The engine can be used to retrieve additional information or execute additional actions.</param>
            <param name="package">The package provides the primary data for the template.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.TargetGroupPersonalizationTemplate.InjectComponentPresentationConditions(Tridion.ContentManager.Templating.Item,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Injects the tcdl:TargetGroup and Condition tags for each component presentation encountered in the output and for which
            conditions are defined.
            </summary>
            <param name="outputItem">Item containing the html (either as text or xml) with component presentations</param>
            <param name="cpConditions">Dictionary of target group conditions as defined for component presentations on the page via the ContentManager</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.TargetGroupPersonalizationTemplate.DetermineComponentPresentationConditions(Tridion.ContentManager.CommunicationManagement.Page)">
            <summary>
            Checks the page for ComponentPresentations with TargetGroup selections and builds the tcdl represention of the condition for
            each. The results are returned as a map, using the combination of template uri and component uri as a key
            </summary>
            <param name="page">Page for which target group conditions need to be determined</param>
            <returns>map of target group conditions for component presentations indexed by combination of template uri and component uri</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.TargetGroupPersonalizationTemplate.GetComponentPresentationKey(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri)">
            <summary>
            Constructs a key string for a component presentation
            </summary>
            <param name="componentUri">uri of the component of the component presentation</param>
            <param name="templateUri">uri of the template of the component presentation</param>
            <returns>a combination of the uris to form a single key to address the component presentation</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.TargetGroupPersonalizationTemplate.AddTargetGroupConditions(System.Text.StringBuilder,Tridion.ContentManager.AudienceManagement.TargetGroupCondition,System.Boolean)">
            <summary>
            Translates target group conditions to a string using tcdl format. Mostly a copy of code in UtilitiesPublish.bas 
            </summary>
            <param name="target">Target StringBuilder to which the conditions are added</param>
            <param name="targetGroupCondition">Object providing input for the conditions that are constructed</param>
            <param name="topLevel">Indicates whether this condition is a toplevel or a nested condition</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplateXmlUtilities">
            <summary>
            This utility class defines static helper functions for various XML related tasks
            of templates (usually accessed through the name TemplateUtilities).
            </summary>
            <remarks>
            Split up from TemplateUtilities to make the individual files smaller.
            Please use TemplateUtilities.static method to access these methods.</remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.SerializeXml(System.Xml.XmlNode)">
            <summary>
            Serialize an XmlElement to a string.
            </summary>
            <param name="node">The XML node to serialize</param>
            <returns>The string representation of the Xml node</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CreateDocumentFromString(System.String)">
            <summary>
            Utility method to construct an XML DOM from an XML input string.
            </summary>
            <param name="xmlString">The XML string to parse</param>
            <returns>An XMLDocument representation of the xmlString.</returns>
            <exception cref="T:System.Xml.XmlException">In case the document can not be read as XML.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CreateDocumentFromStream(System.IO.Stream)">
            <summary>
            Utility method to construct an XML DOM from an XML input stream.
            </summary>
            <param name="xmlStream">The XML stream to parse</param>
            <returns>An XML Document representation of the XML Stream or String.</returns>
            <exception cref="T:System.Xml.XmlException">In case the document can not be read as XML.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CreateDocumentFromStringOrStream(System.Xml.XmlTextReader)">
            <summary>
            Implementation method to construct an XML DOM from an XML input string or a stream.
            </summary>
            <remarks>The document may be an XHTML document with a reference to a DTD,
            so a special kind of entity resolution is used</remarks>
            <param name="xmlReader">The XML document to read</param>
            <returns>An XML Document representation of the XML Stream or String.</returns>
            <exception cref="T:System.Xml.XmlException">In case the document can not be read as XML.</exception>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateXmlUtilities.NumCatalogAccesses">
            <remarks>
            Variable purely meant for testing. But since resolving on all levels works fine
            (as long as there is network access) if there is no special resolver, you
            need something extra to monitor that the catalog is used (a test of the
            GetEntityFromCatalog method alone would not guarantee this method is used.
            Since it is so hard to detect it is used, also makes it noteworthy to test.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.GetStringContentsFromTridionXml(System.String,System.String)">
            <summary>
            Get the string-value result of an XPath query executed on a Tridion xml document
            </summary>
            <param name="tridionXml">The text to parse</param>
            <param name="xpathQuery">The query to execute</param>
            <returns>The found value as a string, or null if that value could not be found</returns>
            <exception cref="T:System.Xml.XmlException">In case the document cannot be parsed, or the XPath expression cannot be executed</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.SelectSingleNode(System.Xml.XmlNode,System.String)">
            <summary>
            Execute an XPath expression on a node returning the first matching node, with a several namespaces
            set up. 
            </summary>
            <param name="node">The node that acts as the context for the query</param>
            <param name="xpath">The XPath expression to execute</param>
            <returns>the first matching node</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.SelectNodes(System.Xml.XmlNode,System.String)">
            <summary>
            Execute an XPath expression on a node, with a several namespaces
            set up. 
            </summary>
            <remarks>
            Remember that XHTML elements need not be in a namespace as far 
            as can be determined (so xpath expression has to take that into account).
            </remarks>
            <param name="node">The node that acts as the context for the query</param>
            <param name="xpath">The XPath expression to execute</param>
            <returns>The matching nodes</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.SelectNodes(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Execute an XPath expression on a navigator node, with a several namespaces
            set up. 
            </summary>
            <remarks>
            Remember that XHTML elements need not be in a namespace as far 
            as can be determined (so xpath expression has to take that into account).
            </remarks>
            <param name="node">The navigator node that acts as the context for the query</param>
            <param name="xpathQuery">The XPath expression to execute</param>
            <returns>The matching nodes</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.SelectNodeAsString(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Utility method to perform an XPath expression on a node, and determine
            the string-value.
            </summary>
            <param name="node">The context node for the XPath evaluation</param>
            <param name="xpathQuery">The query to execute</param>
            <returns>The string-value of the XPath evaluation execution</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.GetTcmUriFromTridionXml(System.String)">
            <summary>
            Utility method to extracts the TcmUri of a Tridion XML representation
            </summary>
            <param name="tridionXml"></param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CreateNamespaceManager(System.Xml.XmlNameTable)">
            <summary>
            Utility method to set up a set of namespaces that can be used by XPath expressions
            </summary>
            <param name="nameTable">The nametable of the document that the namespace manager
            will be used with</param>
            <returns>An initialized namespace manager</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.EscapeXml(System.String)">
            <summary>
            Performs xml escaping on the input string, including single and double quotes, so it is suited for using the result in xml attributes
            </summary>
            <param name="src">string to escape</param>
            <returns>xml escaped string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.ResolveRichTextFieldXhtml(System.String)">
            <summary>
            Perform ResolveXHTML on a document, matching the function in the 
            VBScript Default Template Building Block
            </summary>
            <remarks>
            'img' and 'a' tags with an xlink:href attribute are processed:
             - For images the xlink:href attribute is copied to the src-attribute.
             - For a-tags, a tridion:href attribute is introduced.
            In both cases, the xlink:* attributes on the found elements are removed, and
            StripXhtml is used to clean up the result
            </remarks>
            <param name="inputXhtml">An Xhtml fragment, meant to be a RTF field value</param>
            <returns>A processed version of inputXhtml</returns>
            <exception cref="T:System.Xml.XmlException">In case the input parameter is not a Xhtml</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.StripXhtml(System.Xml.XmlDocument)">
            <summary>
            Perform StripXhtml on a document, matching the function in the VBScript Default Template Building Block
            </summary>
            <remarks>
            Uses the Utilities.StripXHTML.xslt resource.
            </remarks>
            <param name="document">The document to transform</param>
            <returns>The transformed root element of the document</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.PerformXsltTransformation(System.Xml.XmlDocument,System.String,System.Xml.Xsl.XslCompiledTransform@)">
            <summary>
            Utility function to perform an XSLT transformation based on a resource stored in the assembly.
            </summary>
            <remarks>The transformer is cached for performance</remarks>
            <param name="document">The document to transform</param>
            <param name="transformationResourceName">The name of the resource that contains the XSLT 
            stylesheet to transform with</param>
            <param name="cachedTransformer">The object that contains the cached transformer, or will hold 
            the cached transformer, for the transformationResourceName resource</param>
            <returns>The result of the XSLT transformation (or null if the document was null)</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver">
            <summary>
            Custom XmlResolver, which caches the most common XHTML DTDs.
            </summary>
            <remarks>
            This private class is only used in the CreateDocumentFromStringOrStream method.
            
            The following behavior is used:
             - If the absoluteUri passed matches a system id of the catalog,
            the resource is resolved from the internal Resources.XhtmlDtds resource
            folder in this assembly.
             - If no match on system id can be found, the resolving is left to an embedded
            default XmlUrlResolver.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver.GetEntity(System.Uri,System.String,System.Type)">
            <summary>
            Get an entity based on an URI, either from the catalog or directly
            </summary>
            <param name="absoluteUri">The URI to resolve. As mentioned below, public ids
            are also passed in this argument, but should not be mentioned</param>
            <param name="role">The role of this entity (unused)</param>
            <param name="ofObjectToReturn">The type to return (always assumed to be Stream)</param>
            <returns>The found entity (the XmlUrlResolver usually throws exceptions instead
            of returning null)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver.GetEntityFromCatalog(System.Uri)">
            <summary>
            Attempt to get an entity from the XHTML DTD catalog, if the
            URI represents a known system id.
            </summary>
            <param name="absoluteUri">The URI to resolve</param>
            <returns>An opened resource stream for a catalog item, or null
            in case no match could be found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver.InitializeCatalog">
            <summary>
            Ensure the catalog entries cache is initialized (or initialize it now).
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver.GetCatalogResource(System.String)">
            <summary>
            Utility method to get a named resource from the assembly
            (from the Resources/XhtmlDtds subfolder)
            </summary>
            <param name="resourceName">The name of the resource to resolve</param>
            <returns>The opened resource</returns>
            <exception cref="T:System.Exception">Various exceptions in case the resource could
            not be found (so existance should be ensured before the method is called)</exception>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver.Credentials">
            <summary>
            Credentials setter.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplateXmlUtilities.CatalogBasedXmlResolver.CatalogEntry">
            <summary>
            Simple data-structure used to store items from the catalog.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplatingLogger">
            <summary>
            This class provides logging for the .Net templating framework. It makes use of the 
            Tridion Common Logging framework.
            </summary>
            <remarks>
            <para>
            C# fragment templates can use of a logging object directly, it is available under the
            variable name <c>'log'</c>.
            </para>
            <para>
            To make use of the logging framework in a .Net template class, you can get a reference to
            a logging object for your class with a statement like:
            <code>
            private static readonly TemplatingLogger log = TemplatingLogger.GetLogger(typeof(YourClass));
            </code>
            </para>
            <para>
            Messages you log are used in two ways:
            <list type="bullet">
            	<item>Messages are logged to the Tridion Common Logging framework, whose configuration
            is determined in the <c>Tridion.ContentManager.config file</c>. It is possible to log to
            files, Windows log, console, etc. depending on the configuration. By default, only warnings
            and errors are logged, as a Windows event</item>
            	<item>When debugging templates through the Template Builder, log messages appear in the
            'Output' window. What messages appear depends on the selected options under the 
            'Debug|Logging Options' menu.</item>
            </list>
            Like other logging frameworks, there are different levels of messages, where messages will
            only be logged when they match a selected log-level, or are more serious than the selected level.
            </para>
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplatingLogger._debuggingLogger">
            <summary>
            Reference to current debugging logger.
            </summary>
            <remarks>
            Because TemplatingLogger is based on static access
            this cannot be done cleanly. So do it with the littlest amount of code needed
            in a thread static way.
            (since all of engine execution is supposed to be single threaded anyway, so
            can tie it to the thread)
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.GetLogger(System.Type)">
            <summary>
            Get a logger for a specific type
            (the type is used in generated messages).
            </summary>
            <param name="type">The type to create the logger for</param>
            <returns>An initialized logger object</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.SetDebuggingLoggerOnThread(Tridion.ContentManager.Templating.Debugging.DebuggingLogger)">
            <summary>
            Set the debug logger. Any message logged will also be passed
            to the debug logger.
            </summary>
            <remarks>
            This logger is set/ cleared per thread.
            </remarks>
            <param name="debuggingLogger">The DebugLogger to log to, or null to clear
            this logging.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.#ctor">
            <summary>
            Default constructor (does not use a type)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.#ctor(System.Type)">
            <summary>
            Constructor of logger object, with a type reference.
            (used in GetLogger)
            </summary>
            <param name="typeToLogFor">The type whose name will be included in log-messages</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.Debug(System.String)">
            <summary>
            Log a debug message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.Info(System.String)">
            <summary>
            Log an info message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.Warning(System.String)">
            <summary>
            Log a warning.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.Error(System.String)">
            <summary>
            Log an error message.
            </summary>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.Error(System.String,System.Exception)">
            <summary>
            Log an error message with an exception.
            </summary>
            <param name="message">The message to log</param>
            <param name="exception">The exception to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.Log(System.Diagnostics.TraceEventType,System.String)">
            <summary>
            Internal method to perform the logging.
            </summary>
            <param name="severity">The level of the message</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.Log(System.Diagnostics.TraceEventType,System.Diagnostics.TraceEventType,System.String,System.Exception)">
            <summary>
            Internal method to perform the logging.
            </summary>
            <param name="severity">The level of the message</param>
            <param name="severityForDebugLogger">The level of the message when sent to the debugger</param>
            <param name="message">The message to log</param>
            <param name="exception">The exception that this log event relates to</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingLogger.ShouldLogToCommonLogging(System.Diagnostics.TraceEventType)">
            <summary>
            Determine whether the severity of a message is high enough (by configuration)
            to be logged to common logging.
            </summary>
            <remarks>
            See TT59618. Is internal for testing.
            </remarks>
            <param name="severity">The severity level of the message to log</param>
            <returns>Whether the message is severe enough for common logging</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.MediatorRegistry">
            <summary>
            Registry of mediators.
            The registry is externally configured through an configuration of the format
            ![CDATA[
            <mediators>
                <mediator class="FullClassName" matchMIMEType="maintype/subtype" assemblyPath="PathToAssembly"/>
            </mediators>
            ]]
            where AssemblyPath is optional, and if defined should be a UNC path to the assembly file (otherwise
            the instantion is attempted in the current assembly).
            The MIMETypes must be unique within the configuration.
            TODO (sanderb): Allow for wildcards in mimetype? (would require different (ordered) storage)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.MediatorRegistry.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Tridion.ContentManager.Templating.MediatorRegistry"/> class. 
            Sets up the registry including determining whether all types are available.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.MediatorRegistry.GetMediator(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Instantiate a mediator to perform a transformation with.
            </summary>
            <param name="template">The template to determine the mediator for (the mediator is determined
            based on the template type of the template)</param>
            <returns>An instantiated mediator for the template, or null if such a mediator could not
            be determined.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.MediatorRegistry.GetMediator(Tridion.ContentManager.Templating.TemplateWrapper)">
            <summary>
            Instantiate a mediator to perform a transformation with.
            </summary>
            <param name="template">The template to determine the mediator for (the mediator is determined
            based on the template type of the template)</param>
            <returns>An instantiated mediator for the template, or null if such a mediator could not
            be determined.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.MediatorRegistry.HasMediatorForMimeType(System.String)">
            <summary>
            Returns true if a mediator exists for the given mimetype. 
            </summary>
            <param name="mimeType">Mime type to verify existence of mediator for</param>
            <returns>true when the mimetype maps to a mediator</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.MediatorRegistry.MediatorInfo">
            <summary>
            Data structure for holding information on an individual mediator within the mediator registry.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Package">
            <summary>
            Representation of the context of a transformation,
            containing both the inputs and the outputs of the transformation.
            </summary>
            <remarks>
            <para>
            The implementation of a package is a list of Item-objects that is partly a
            dictionary (items can be retrieved by name), and partly a stack (items can
            be pushed and popped on and from the list).</para>
            <para>This object is available in implementations of <see cref="T:Tridion.ContentManager.Templating.Assembly.ITemplate"/> and <see cref="T:Tridion.ContentManager.Templating.Expression.IFunctionSource"/>; and under the
            name <c>package</c> within C# fragment templates.
            </para>
            <para>
            There are three items that play a role at the beginning and end of a page and component template:
            <list type="bullet">
            <item>In the case of a component template, the package will contain an item named <c>'Component'</c> representing
            the component being rendered.</item>
            <item>In the case of a page template, the package will contain an item named <c>'Page'</c> representing
            the page being rendered.</item>
            <item>When the page or component template is completely rendered, the templating engine will look
            for an item named <c>'Output'</c>, which acts as the main output of the rendered template. So you
            should ensure at some point in page or component template such an item is added.</item>
            </list>
            (the page or component template being rendered can be accessed outside the package, through
            <c><see cref="P:Tridion.ContentManager.Templating.Package.Engine"/>.PublishingContext.ResolvedItem.Template</c>.)
            </para>
            <para>
            See the <a href="/Overview/Templating concepts/Package.html">overview</a> documentation
            for some more information.
            </para>
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.OutputName">
            <summary>
            Item name 'Output', used for the main output of the template execution.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.TitleName">
            <summary>
            Item name 'Title', used for titles.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.PageName">
            <summary>
            Item name 'Page', used for the page being processed.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.ComponentName">
            <summary>
            Item name 'Component', used for the item of the component currently processed.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.ComponentTemplateName">
            <summary>
            Item name 'ComponentTemplate', used for the item of the component template of the component currently processed.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.ComponentsName">
            <summary>
            Item name 'Components', used as default name for the components being written.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.CurrentRepeatingFieldName">
            <summary>
            Item name 'Field', used for current field being processed in a Dreamweaver template.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package.TemplateRepeatIndexFieldName">
            <summary>
            Item name 'TemplateRepeatIndex', used for the storage of the current repeating region index.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Package._elements">
            <summary>
            The items in the package.
            The stack-order is that the most recently added item is the
            first item in the list.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.#ctor(Tridion.ContentManager.Templating.Engine)">
            <summary>
            Constructor for a new empty package.
            </summary>
            <param name="engine">The engine this package will be used in combination with</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.#ctor(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.IdentifiableObject)">
            <summary>
            Constructor for a package with the item being rendered in it
            </summary>
            <param name="engine">The engine this package will be used in combination with</param>
            <param name="itemToRender">The initial item to put in the package</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetByName(System.String)">
            <summary>
            Get an item from the package by name.
            </summary>
            <param name="name">The name of the item to retrieve</param>
            <returns>The top-most item in the package by that name, or null 
            if there is no item in the package with that name.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetByType(Tridion.ContentManager.Templating.ContentType)">
            <summary>
            Get the an item from the package by type.
            </summary>
            <param name="contentType">The content type of item that should be returned.</param>
            <returns>The top-most item in the package that matches the contentType, or null 
            if there is no item in the package that matches the content type.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetAllByType(Tridion.ContentManager.Templating.ContentType)">
            <summary>
            Return all items in the package that match a certain
            content type.
            </summary>
            <param name="contentType">The content type of items that should be returned.</param>
            <returns>A possibly empty list of items that match the content type.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetEntries">
            <summary>
            Returns the entire package as a list of named items using KeyValuePair objects.
            </summary>
            <remarks>
            This is a live list, changes made to the list will affect the package.
            </remarks>
            <returns>The package contents as a list with KeyValuePair objects</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.Remove(Tridion.ContentManager.Templating.Item)">
            <summary>
            Remove an item from the package. If the item is present
            in the package multiple times, only the first occurences is removed.
            </summary>
            <param name="item">The item to remove from the package</param>
            <returns>If an item could be removed and it had a name, the name of
            the removed item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.RemoveByReference(Tridion.ContentManager.Templating.Item)">
            <summary>
            Remove an item from the package. If the item is present
            in the package multiple times, only the first occurence is removed.
            </summary>
            <remarks>
            This method works by identity comparisons, and is only meant to clean
            up an exact item found (so items may not be serialized/ deserialized in between).
            </remarks>
            <param name="item">The item to remove from the package</param>
            <returns>If an item could be removed and it had a name, the name of
            the removed item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.PushItem(Tridion.ContentManager.Templating.Item)">
            <summary>
            Place an unnamed item in the package at the top of the stack.
            </summary>
            <param name="item">The item to put in the package.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.PushItem(System.String,Tridion.ContentManager.Templating.Item)">
            <summary>
            Place an item in the package at the top of the stack under the
            name given.
            </summary>
            <param name="name">The name to be used in the package for the item.</param>
            <param name="item">The item to put in the package.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.WritePackageXmlTo(System.IO.Stream)">
            <summary>
            Writes the current contents of the package into the given stream as XML.
            </summary>
            <param name="packageStream">The stream to which to write the package contents.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.WritePackageXmlTo(System.String,System.String,System.Boolean)">
            <summary>
            Writes the current contents of the package into the given stream as XML.
            </summary>
            <param name="directory">The location to create the file(s).</param>
            <param name="packageName">The base name of the package</param>
            <param name="writeItemValuesSeparately">Whether or not item values should be written to separate files</param>
            <returns>The generated filename</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.EvaluateExpression(System.String)">
             <summary>
             Evaluates an expression, which may contain variable references to items in the Package: 
             either user-created package items (by name) or predefined variable names (see the public fields of Package).
             </summary>
             <param name="expression">The expression.</param>
             <returns>The result of the evaluation as a string.</returns>
             <remarks>
             <para>
             The following features and operators are supported:
             <list type="bullet">
             <item>numeric literals, string literals (double-quote syntax only), Boolean literals (true or false)</item>
             <item>variable references</item>
             <item>field references (the "dot" operator)</item>
             <item>unary operators: +, -, ~, ! </item>
             <item>conditional operator: ?: </item>
             <item>parentheses: ()</item>
             </list>
             </para>
             <para>
             A variable reference is replaced by its string representation or an empty string if it cannot be evaluated.
             For example, if the input expression is <c>Component.Schema.Name == "My first Schema"</c>
             and <c>Component.Schema.Name</c> evaluates to "Some Schema", then the expression
             is rewritten to <c>"Some Schema" == "My first Schema"</c>.
             </para>
             </remarks>
             <example>
             <code>
             public void Transform(Engine engine, Package package)
                {			
            	    package.PushItem(package.CreateStringItem(ContentType.Text, package.EvaluateExpression("121")));
            	    package.PushItem(package.CreateStringItem(ContentType.Text, package.EvaluateExpression("10-3")));
            	    package.PushItem(package.CreateStringItem(ContentType.Text, package.EvaluateExpression("3>=3")));
            	    package.PushItem(package.CreateStringItem(ContentType.Text, package.EvaluateExpression("true")));
            	    package.PushItem("String literal",package.CreateStringItem(ContentType.Text, package.EvaluateExpression("\"abc\"")));
            	    //Not supported, will throw an exception
            	    //package.PushItem(package.CreateStringItem(ContentType.Text, package.EvaluateExpression("\"abc\".length")));
            
            	    //Assume running with a Page (context object)
            	    package.PushItem("Page.Title", package.CreateStringItem(ContentType.Text, package.EvaluateExpression("Page.Title")));
            	    package.PushItem("Page.Name", package.CreateStringItem(ContentType.Text, package.EvaluateExpression("Page.Name")));
                 package.PushItem("Page.Name", package.CreateStringItem(ContentType.Text, package.EvaluateExpression("Page.Name == \"MyPage\"")));
            	    package.PushItem("Page.ID", package.CreateStringItem(ContentType.Text, package.EvaluateExpression("Page.ID")));
                 //Returns false in the context of a page, true in the context of a component
                 package.PushItem("!Page.ID", package.CreateStringItem(ContentType.Text, package.EvaluateExpression("!Page.ID")));
            
            	    //Assume running with a Component (context object)
            	    package.PushItem("Component.Fields.NewField", package.CreateStringItem(ContentType.Html, package.EvaluateExpression("Component.Fields.NewField")));
            	    package.PushItem("Component.NewField", package.CreateStringItem(ContentType.Html, package.EvaluateExpression("Component.NewField")));
            	    package.PushItem("NewField", package.CreateStringItem(ContentType.Html, package.EvaluateExpression("NewField")));			
            	    package.PushItem("Component.Schema.Title", package.CreateStringItem(ContentType.Html, package.EvaluateExpression("Component.Schema.Title")));
             }
             </code>
             </example> 
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.EvaluateExpressionToBool(System.String)">
            <summary>
            Evaluates the expression to bool. <see cref="M:Tridion.ContentManager.Templating.Package.EvaluateExpression(System.String)"/> contains a full description with examples.
            The only difference with this overload is the return type.
            </summary>
            <param name="expression">The expression.</param>
            <returns>
            Anything that is not <c>false</c> or empty is considered <c>true</c>
            </returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.WritePackageXmlTo(System.IO.Stream,System.Boolean,System.String,System.String)">
            <summary>
            Writes the current contents of the package into the given stream as XML.
            </summary>
            <param name="packageStream">The stream to which to write the package contents.</param>
            <param name="writeItemValuesSeparately">Whether or not item values should be written to separate files</param>
            <param name="outputDirectory">In case item values are written in separate files, where to create those files</param>
            <param name="packageName">In case item values are written in separate files, what the (unique) name of the package is</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.WriteItemDataToXml(Tridion.ContentManager.Templating.Item,System.Xml.XmlWriter)">
            <summary>
            Write the data of one package Item to an open Xml writer
            </summary>
            <param name="item">The item to write</param>
            <param name="itemWriter">The xml writer to write to</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.EncodeTextContent(System.String)">
            <summary>
            Encode string content to be used in package item XML.
            </summary>
            <remarks>All user based string content attributes in a package are
            URL encoded in case they contain unexpected characters</remarks>
            <param name="input">The text to encode</param>
            <returns>The URL encoded input</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.DecodeTextContent(System.String)">
            <summary>
            Decode string content used in package item XML.
            </summary>
            <remarks>All user based string content attributes in a package are
            URL encoded in case they contain unexpected characters</remarks>
            <param name="input">The text to decode</param>
            <returns>The URL decoded input</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.ReadFromPackageXml(System.Xml.XmlDocument)">
            <summary>
            Reconstruct a package from a document. The items are simply added
            to the package, so the user of this method should ensure the package
            is empty initially.
            </summary>
            <param name="packageDocument">The package representing document to
            process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetChildTextContents(System.Xml.XmlNode)">
            <summary>
            Get the text-value of an element so e.g. 'bar' from
            <foo>bar</foo>.
            </summary>
            <param name="element">The element whose content to gather</param>
            <returns>The gathered content (empty string if no children present)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateItemContentSummary(Tridion.ContentManager.Templating.Item)">
            <summary>
            Create a summary of the data in a package, for the GUI
            </summary>
            <param name="item">The item whose content should be summarized</param>
            <returns>A summary of the data in a package</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetCallableFunctions">
            <summary>
            Retrieve the list of function sources.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetCallableFunctionTypes">
            <summary>
            Retrieve callable function types.
            </summary>
            <returns>List of function types</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetFunctionSourceCollection">
            <summary>
            Retrieve the configured function sources from the template settings configuration.
            </summary>
            <returns>Function source collection</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateStringItem(Tridion.ContentManager.Templating.ContentType,System.String)">
            <summary>
            Convenience factory method to create a string-value based Item
            </summary>
            <param name="contentType">The content-type of the item</param>
            <param name="value">The value of the item, may be null</param>
            <returns>An instantiated item object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateStreamItem(Tridion.ContentManager.Templating.ContentType,System.IO.Stream)">
            <summary>
            Convenience factory method to create a string-value based Item
            </summary>
            <param name="contentType">The content-type of the item</param>
            <param name="value">The value of the item, may be null</param>
            <returns>An instantiated item object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateXmlDocumentItem(Tridion.ContentManager.Templating.ContentType,System.Xml.XmlDocument)">
            <summary>
            Convenience factory method to create a string-value based Item
            </summary>
            <param name="contentType">The content-type of the item</param>
            <param name="value">The value of the item, may be null</param>
            <returns>An instantiated item object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateTridionItem(Tridion.ContentManager.Templating.ContentType,Tridion.ContentManager.TcmUri)">
            <summary>
            Convenience factory method to create a Tridion based Item.
            </summary>
            <param name="contentType">The content-type of the item</param>
            <param name="itemURI">The TCM URI of the item to create</param>
            <returns>An instantiated Item object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateTridionItem(Tridion.ContentManager.Templating.ContentType,Tridion.ContentManager.IdentifiableObject)">
            <summary>
            Convenience factory method to create a Tridion based Item.
            </summary>
            <param name="contentType">The content-type of the item</param>
            <param name="tridionItem">The item that has been retrieved from the Content Manager</param>
            <returns>An instantiated Item object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateHtmlItem(System.String)">
            <summary>
            Convenience factory method to create a HTML based Item (also recognized as HTML in output).
            </summary>
            <param name="htmlContent">The HTML content for the item</param>
            <returns>A new item with content-type html and the passed content, marked as being
            HTML</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateMultimediaItem(Tridion.ContentManager.TcmUri)">
            <summary>
            Convenience factory method to create a stream based item for a specific multimedia component.
            </summary>
            <param name="componentURI">The URI of the multimedia component to publish</param>
            <returns>The newly created MultiMedia item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateMultimediaItem(Tridion.ContentManager.ContentManagement.Component)">
            <summary>
            Convenience factory method to create a stream based item for a specific multimedia component.
            </summary>
            <param name="component">The multimedia component to create the item for</param>
            <returns>The newly created MultiMedia item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.CreateComponentUriListItem(Tridion.ContentManager.Templating.ContentType,System.Collections.Generic.IList{Tridion.ContentManager.TcmUri})">
            <summary>
            Convenience factory method to create a TcmUri component list based Item.
            </summary>
            <param name="contentType">The content-type of the item</param>
            <param name="itemURIs">The TCM URI list for the item to create</param>
            <returns>An instantiated item object.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetSources(System.String)">
            <summary>
            <see cref="T:Tridion.ContentManager.Templating.ISource"/> implementation.
            Retrieve the (list of) sub source(s) of this package source. The returned sub source(s)
            can be used again to drill down the expression further.
            </summary>
            <remarks>
            For example, calling
            <code>GetSources("Component.Schema")[0].GetValue("ID")</code>
            would result in the schema URI of the first item named 'Component' in the package, if such
            an item exists and represents a Tridion component.
            </remarks>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of sub sources that match the partially qualified name in the package.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetValue(System.String)">
            <summary>
            <see cref="T:Tridion.ContentManager.Templating.ISource"/> implementation.
            Determine the string value for a source-expression on the package.
            </summary>
            <remarks>
            For example, for input <c>Component.Schema.ID</c>
            the result could be the schema URI of the first item named 'Component' in the package, if such
            an item exists and represents a Tridion component.
            </remarks>
            <param name="fullyQualifiedName">The source expression to get the value for</param>
            <returns>The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.GetContentType">
            <summary>
            <see cref="T:Tridion.ContentManager.Templating.ISource"/> dummy implementation
            (a package does not have a content type).
            </summary>
            <returns>A dummy return value ("application/unknown")</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Package.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Package.FunctionSources">
            <summary>
            Available Function sources for this package.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Package.ExtensionObjects">
            <summary>
            Gets or sets dependency between extension objects types and the extension objects(for avoiding creating new object each time).
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromHtmlTemplate">
            <summary>
            This template goes over all hyperlinks found in an HTML text (whose content should be
            placed in an item named 'Output', and should have a Tcm Uri property).
            For each relative path found, it is attempted to resolve the path as multimedia component
            (through webdav paths), and if that is possible:
             - The multimedia component is added to the package as a binary.
             - The link text in the template is replaced by a reference to the multimedia component.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromHtmlTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            ITemplate implementation
            </summary>
            <param name="engine">Reference engine</param>
            <param name="package">Package to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromHtmlTemplate.ResolveTemplateBinaries(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package,Tridion.ContentManager.TcmUri,Tridion.ContentManager.Templating.Templates.ExtractBinariesContentWrapper)">
            <summary>
            Resolve the binaries found in the template. Also alter the template so that
            it contains the converted strings).
            </summary>
            <param name="engine">Reference to the engine for resolving data</param>
            <param name="package">The package to operate on</param>
            <param name="baseItemTcmUri">The URI of the items where URLs should be relative to</param>
            <param name="contentWrapper">The content to transform</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromHtmlTemplate.ResolveWebDavUrl(System.String,System.String,Tridion.ContentManager.Templating.Engine)">
            <summary>
            Utility function to try and find a tridion item for relative URL.
            
            In many cases, the urlToResolve will not be resolved back to Tridion item
            (if the URL is fully qualified, if the path is not relative, if the path
            is relative but cannot be resolved to an object in the CM). In all those cases
            null will be returned.
            
            If based on the urlToResolve and the webDAVBaseURL a webDAVUrl can be constructed
            that can be resolved, its TCM URI is returned.
            </summary>
            <param name="urlToResolve">The url to resolve. This can be any URL, but something
            useful with it will only be done if it represents a (relative) WebDAV path</param>
            <param name="webDavBaseUrl">The base-URL where urlToResolve items should be located relative to
            (if urlToResolve is relative)</param>
            <param name="engine">Reference to the engine, used for CM lookups.</param>
            <returns>The Tcm URI of the component to resolve, or null if it could not be
            resolved.</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ExtractBinariesContentWrapper">
            <summary>
            Interface shared between ExtractBinariesFromText and ExtractBinariesFromXml, that
            abstracts from the underlying data being a text-string or XML.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.LinkReferenceWrapper">
            <summary>
            Structure representing either the XML or text related context of a found link attribute
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText">
            <summary>
            Part of ExtractBinariesFromHtmlTemplate, in case the output item is Text.
            
            Implementation for ExtractBinariesContentWrapper where underlying data is text and
            content is processed using regular expressions.
            
            This is an internal class, some methods must be public because an interface is implemented.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="text">The html text to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.GetLinkAttributes">
            <summary>
            Get an Iterator of all the link attribute values in the document.
            </summary>
            <returns>An enumerator of link attribute matches.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.GetLinkAttributes(System.Text.RegularExpressions.Regex[])">
            <summary>
            Get an Iterator of all the link attribute values in the document.
            </summary>
            <param name="expressions">The regular expressions to execute on the text</param>
            <returns>An enumerator of link attribute matches.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.GetAttributeValue(Tridion.ContentManager.Templating.Templates.LinkReferenceWrapper)">
            <summary>
            The the attribute value for a linkAttribute
            </summary>
            <param name="linkAttribute">The link attribute representation</param>
            <returns>The attribute value as a string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.ProcessLinkChange(Tridion.ContentManager.Templating.Templates.LinkReferenceWrapper,Tridion.ContentManager.TcmUri)">
            <summary>
            Add link attributes for a target item to an existing attribute,
            or change URL to a TCM URI in a CSS url reference.
            </summary>
            <param name="linkAttribute">The link attribute representation</param>
            <param name="targetItemUri">The Tcm Uri of the target</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.ReplaceValue(Tridion.ContentManager.Templating.Templates.LinkReferenceWrapper,System.String,System.String)">
            <summary>
            Replace an existing link attribute value in a link reference.
            </summary>
            <param name="linkAttribute">The link to process</param>
            <param name="replacementValue">The new value to store</param>
            <param name="surroundingCharacter">Surrounding attribute value character</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.InjectAttribute(Tridion.ContentManager.Templating.Templates.LinkReferenceWrapper,System.String,System.Object)">
            <summary>
            Utility method to change a link attribute, by entering a new value.
            </summary>
            <param name="linkAttribute">The link reference representation to alter</param>
            <param name="replacementFormatString">The string-format to use in updating the value</param>
            <param name="replacementValue">The new value to enter into the document</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromText.Content">
            <summary>
            Retrieve the HTML content
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml">
            <summary>
            Part of ExtractBinariesFromHtmlTemplate, in case the output item is Xml.
            
            Implementation for ExtractBinariesContentWrapper where underlying data is Xml and
            content is processed using DOM access, and regular expressions for the CSS.
            
            This is an internal class, some methods must be public because an interface is implemented.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml.#ctor(System.Xml.XmlDocument)">
            <summary>
            Constructor
            </summary>
            <param name="xmlDocument">The document to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml.GetLinkAttributes">
            <summary>
            Get an Iterator of all the link attribute values in the document.
            </summary>
            <returns>An enumerator of link attribute matches.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml.GetAttributeValue(Tridion.ContentManager.Templating.Templates.LinkReferenceWrapper)">
            <summary>
            The the attribute value for a linkAttribute
            </summary>
            <param name="linkNode">The link attribute representation</param>
            <returns>The attribute value as a string</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml.ProcessLinkChange(Tridion.ContentManager.Templating.Templates.LinkReferenceWrapper,Tridion.ContentManager.TcmUri)">
            <summary>
            Add link attributes for a target item to an existing attribute,
            or change URL to a TCM URI in a CSS url reference.
            </summary>
            <param name="linkNode">The link attribute representation</param>
            <param name="targetItemUri">The Tcm Uri of the target</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml.AddTridionAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Utility method to add a tridion attribute to an element.
            </summary>
            <param name="element">The element to add the attribute on</param>
            <param name="name">The name of the attribute to add</param>
            <param name="value">The value of the attribute to add</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml.GetCssLinkAttributes">
            <summary>
            Get all the CSS linking attributes, as regular expression matches on the
            text content of style elements
            </summary>
            <returns>LinkAttributeWrapper representing regular expression matches on the 
            styleContents text found in this method, which is wrapped in the _currentCssHandler
            items on this object</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Templates.ExtractBinariesFromXml.Content">
            <summary>
            Retrieve the XML document
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ExtractComponentsFromPageTemplate">
            <summary>
            This template gets the page from the package, and adds a ComponentPresentation item for each 
            component presentation on the page.
            It also adds a Components item, which is a list of all components on the page.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ExtractComponentsFromPageTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of ITemplate, to perform the template functionality
            </summary>
            <param name="engine">The context engine</param>
            <param name="package">The package to operate on</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate">
            <summary>
            .Net template for executing a component query on a folder, and performing filtering.
            Currently this template can perform two tasks:
             - Do a folder query
             - Perform filtering on a component presentation array filter.
            The filtering tasks possible include inclusion of exclusion based on component source
            data, sorting the results, and limiting the number of results.
            If no folder query is specified, the components currently in the package are filtered.
            
            All the filtering of the component presentations is only done on the component part of
            the component presentation, it is not possible to filter or sort on aspects of the template.
            
            The output is stored as an Item named 'Components', and contains xml representing a 
            ComponentPresentationList (possibly empty, not null). In most cases, the template URI
            will not be filled out in this list).
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of ITemplate interface.
            This method will throw a TemplatingException if the folder to be queried is not specified,
            or cannot be found.
            </summary>
            <param name="engine">The engine used as context for the transformation</param>
            <param name="package">The package serving as in- and output for the transformation.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.DetermineTemplateURI">
            <summary>
            Determines and localizes the (optional) template uri that is specified as a Component Template filter parameter.
            </summary>
            <returns>The localized template uri or null when no uri was specified</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.CreateComponentTemplateSchemaExpression(Tridion.ContentManager.TcmUri)">
            <summary>
            Builds an expression to check if a schema is part of the set of schemas accepted by the 
            component template identified by [componentTemplateUri]. 
            </summary>
            <param name="componentTemplateUri"></param>
            <returns>the expression for the component template uri</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">Throws an TemplatingException when the URI is invalid, not a Comp. Template or the URI does not exist</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.AddToFilterExpression(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Little helper to add an [addition] to an [expression] using [mode] to concatenate them
            </summary>
            <param name="expression">stringbuilder containing the expression to append to</param>
            <param name="addition">partial expression to add</param>
            <param name="mode">mode (for example &amp;&amp; or ||) used to concatenate the expresions</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.CreateComponentPresentationList(System.Collections.Generic.IList{Tridion.ContentManager.ContentManagement.RepositoryLocalObject},Tridion.ContentManager.TcmUri)">
            <summary>
            Utility function to create a ComponentPresentation list based on a component URIs list.
            </summary>
            <param name="components">The component list</param>
            <param name="componentTemplateUri">Optional uri used as compenent template uri for the component presentation</param>
            <returns>A newly created ComponentPresentationList</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.DetermineFolderURI">
            <summary>
            Determine the Folder URI to query.
            Consists of two steps:
            Get the folder URI as a property from the package.
            Update that retrieved URI to use the current publication.
            </summary>
            <returns>The folder URI to query, or null if no query parameter for the folder
            was set.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.GetQueryParameter(System.String)">
            <summary>
            Get a query parameter from the package.
            </summary>
            <param name="parameterName">The query parameter to retrieve</param>
            <returns>The parameter, or null if the parameter is not present or empty</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.GetTridionObjectSource(Tridion.ContentManager.TcmUri)">
            <summary>
            Determine a source for a component URI.
            TODO (sanderb): This method is now in one specific template, but perhaps this (caching) 
            should occur on a different level?
            </summary>
            <param name="uri">The URI to determine the source for</param>
            <returns>An ISource for the Tridion object, or null if no source could be determined</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.GetSourceValue(Tridion.ContentManager.TcmUri,System.String)">
            <summary>
            Determine a source result value for a TcmUri, by creating a source
            for it and evaluating the expression.
            TODO (sanderb): This method is now in one specific template, but perhaps this (caching) 
            should occur on a different level?
            </summary>
            <param name="uri">The Tridion uri of the object to resolve</param>
            <param name="sourceExpression">The fully qualified name to resolve</param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.Filter(Tridion.ContentManager.Templating.IComponentPresentationList,Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.FilterFunction)">
            <summary>
            Filter a list of component presentations, returning a new list with
            the filtered result.
            TODO (sanderb): That a new list is returned is essentially
            an implementation detail, since foreach does not like that the list
            being altered.
            </summary>
            <param name="componentPresentations">The list of component presentations to filter</param>
            <param name="filter">The filter function to apply</param>
            <returns>A new filtered list</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.ComponentFilter(Tridion.ContentManager.Templating.ComponentPresentation)">
            <summary>
            Filter that determines whether the component URI of a CP really represents 
            a component.
            </summary>
            <remarks>FilterFunction delegate implementation</remarks>
            <param name="componentPresentation">The component presentation to check</param>
            <returns>Whether the component URI of the presentation is really of a component</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.QueryFilter(Tridion.ContentManager.Templating.ComponentPresentation,System.String)">
            <summary>
            Filter that checks whether a component presentation matches a specified filter expression.
            </summary>
            <remarks>Used via anonymous FilterFunction delegate implementation</remarks>
            <param name="componentPresentation">The component presentation to check</param>
            <param name="filterQuery">The filter expression to apply</param>
            <returns>Whether the component presentation matches the filter</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.ComponentComparison(Tridion.ContentManager.Templating.ComponentPresentation,Tridion.ContentManager.Templating.ComponentPresentation)">
            <summary>
            System.Comparison delegate implementation, used to optionally sort
            the found component URI list. The comparison works on component URIs
            </summary>
            <param name="componentPresentation1">The first parameter to compare</param>
            <param name="componentPresentation2">The second parameter to compare</param>
            <returns>-1 if value(uri1) is less than value(uri1), +1 if value(uri1) is greater
            then value(uri2), or zero if they are equal. The sort direction is already
            taken into account in this value.</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ComponentQueryTemplate.FilterFunction">
            <summary>
            Delegate definition to allow filtering of component(-presentation)s.
            </summary>
            <param name="componentPresentation">The component presentation to check</param>
            <returns>Whether or not the URI matches the filter</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate">
            <summary>
            Template that will resize images in the package.
            The binary stream of the image is changed, and a filename suffix property that 
            includes the new size is appended to the image.
            
            The following image types are supported:
             - GIF
             - JPG
             - PNG
             - BMP
            The following parameters are used (all optional):
             - ImageResizer.Width, an (integer) number indicating the resize width of the image in pixels (defaults to 100).
             - ImageResizer.Height, an (integer) number indicating the resize height of the image in pixels (defaults to 100).
            If only width or only height is specified, the other size parameter is determined relatively. If both are specified,
            the image is resized so that it will fit in a 'box' of those new values (so the original aspect ratio is always
            maintained).
             - ImageResizer.Percentage, an (integer) number indicating the resize percentage (e.g. 200 is twice as big, 50 is
            half size). If a Width or Height is specified, the percentage is not used even if specified.
             - ImageResizer.ItemName, a string indicating the name of the image-item in the package to process (by default, all images
            found in the package are processed).
             </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of ITemplate.
            </summary>
            <param name="engine">Reference to engine</param>
            <param name="package">The package to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.ResizeImage(Tridion.ContentManager.Templating.Item,System.Int32,System.Int32,System.Int32)">
            <summary>
            Resize one image Item to a specified width and height.
            </summary>
            <param name="imageItem">The image to process</param>
            <param name="newWidth">The new width of the image (or -1 if unspecified)</param>
            <param name="newHeight">The new height of the image (or -1 if unspecified)</param>
            <param name="newPercentage">The new height of the image (or -1 if unspecified)</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.SetImageSuffixProperty(Tridion.ContentManager.Templating.Item,System.String)">
            <summary>
            Set a suffix filename aspect property on the item, based on the changed width and height.
            </summary>
            <param name="item">The item to set a filename suffix property on</param>
            <param name="suffixString">The generated suffix to set</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.SetTemplateAsVariantIdProperty(Tridion.ContentManager.Templating.Item)">
            <summary>
            Set the template of the currently acting compound template on the image item
            (not the image resizer template itself, as what actually counts is the parameters set).
            </summary>
            <param name="imageItem">The item to set the template on.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.LoadImage(Tridion.ContentManager.Templating.Item)">
            <summary>
            Added a utility method to wrap reading an image item into an Image object,
            including exception handling.
            </summary>
            <param name="imageItem">The item to load</param>
            <returns>The image representation of the item</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.DetermineNewSize(System.Int32@,System.Int32@,System.String@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Determine a new width and height of an image based on input parameters.
            The original aspect of the image is never changed, so the the width and
            height are adjusted to have the same relation.
            If a newWidth and newHeight are set, the image is resized to fit within that
            dimension, with the image being as large as possible. So either the 
            resize width or height will be set to newWidth or newHeight, and the other axis
            value is determined based on the aspect ratio (but will be smaller than the new...
            value specified).
            If either of those values are set, the other value is calculated using the
            original aspect of the image.
            If only a newPercentage is set, the new values are determined based on the
            original size.
            If no parameters are set, a default width and height are used.
            </summary>
            <param name="resultWidth">The result width to resize to</param>
            <param name="resultHeight">The result height to resize to</param>
            <param name="suffixProperty">The result suffix property value, generated from the inputs</param>
            <param name="originalWidth">The original width of the image to resize</param>
            <param name="originalHeight">The original height of the image to resize</param>
            <param name="newWidth">The specified (maximum) width of the image to resize, or -1 if
            this parameter is not set</param>
            <param name="newHeight">The specified (maximum) height of the image to resize, or -1 if
            this parameter is not set</param>
            <param name="newPercentage">The percentage to resize the image with, or-1 if
            this parameter is not set. If either newWidth or newHeight is set, this
            parameter is not used.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.GetParameterAsInt(Tridion.ContentManager.Templating.Package,System.String)">
            <summary>
            Get a template parameter including integer conversion. If the parameter
            cannot be found or is not an integer, -1 is returned.
            </summary>
            <param name="package">The package context to determine the parameter value from</param>
            <param name="parameterName">The full name of the parameter to look up</param>
            <returns>The value for the parameter, or -1 if not found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.GetParameter(Tridion.ContentManager.Templating.Package,System.String)">
            <summary>
            Get a template parameter including integer conversion. 
            </summary>
            <param name="package">The package context to determine the parameter value from</param>
            <param name="parameterName">The full name of the parameter</param>
            <returns>The found value for the parameter, or null in case no parameter value could
            be determined.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ImageResizerTemplate.GetImageFormat(Tridion.ContentManager.Templating.ContentType)">
            <summary>
            Determine the imageformat equivalent of a content-type, or null
            if the content-type does not represent a supported image type.
            </summary>
            <param name="contentType">The content-type to process</param>
            <returns>The imageformat equivalent of the content type, or null if
            such a type could not be determined.</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.PublishBinariesInPackageTemplate">
            <summary>
            Template to publish all binaries in a package (meaning all
            items that have a TcmUri and a FileName) property,
            by calling PublishBinary on their stream content,
            and filling out the published path property in the item.
            
            You always want to include this template in the overall compound template, in stages
            before references to the binaries are used (like in link resolving that includes the binaries).
            All binaries are published at most once with this routine (only if the published path is not set yet), 
            so it is possible to call this template multiple times.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.PublishBinariesInPackageTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            ITemplate implementation
            </summary>
            <param name="engine">Context engine</param>
            <param name="package">The package to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.PublishBinariesInPackageTemplate.ConstructFileName(Tridion.ContentManager.Templating.Item)">
            <summary>
            Construct a filename for an item.
            </summary>
            <remarks>Based on the properties of the item. The filename property must be set, but
            there can be other aspects set on the item that are taken into account in the filename</remarks>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.PublishBinariesInPackageTemplate.GetPropertyValue(Tridion.ContentManager.Templating.Item,System.String)">
            <summary>
            Get a property value from an item, or an empty string if the property value
            is missing or null.
            </summary>
            <remarks>Simple helper for ConstructFileName, to access item property values</remarks>
            <param name="item">The item to determine the property value for</param>
            <param name="propertyName">The name of the property to retrieve</param>
            <returns>The property value, or an empty string if the property is missing or null</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate">
            <summary xmlns:tridion="http://www.tridion.com/ContentManager/5.0">
            .Net assembly template for resolving templating links in HTML output. The expected input consists of an HTML file with in it tags like e.g.:
            <a tridion:href="${sourceExpression}" href="dummy.html" target="_blank">hyperlink tag </a>with optionally around those tags a tag like e.g.:
            <div tridion:component="tcm:8-278" tridion:componenttemplate="tcm:8-259-32">...</div>to indicate a component template context (otherwise, this
            context is not used).
            
            Possible attributes possible on the element: - tridion:href, *obligatory* attribute containing a source expression within ${...}, that should
            resolve to an URI (of either a component or a page) (it may also contain a URI directly). - tridion:textonfail, boolean indicating whether the
            text should still be shown if the link cannot be resolved (default is what is default in TCDL, true). - tridion:excludetemplateuri, an explicit
            component template to exclude. By default, this is tcm:0-0-0 (in version 40 and below of this file, the component template uri to exclude was
            taken from the context component template, but this is almost never a good idea since the component linked to will likely be a different one, see
            TT59444). - tridion:type, the type of link to be created. The value can be Page, Component or Binary, although any other value will just be
            copied over (default is either Component or Page, depending on destination URI). The value can also be Multimedia, in this special case the
            original element is retained, only the target attribute of the published path of the MultiMedia component associated with the component
            referenced in tridion:href is replaced. - tridion:targetattribute, only used if tridion:type="Multimedia", the target attribute where the
            published path will be written, defaults to 'href'.  - tridion:anchor, to add an anchor for page links - tridion:variantid, to set the variant to
            link to
            
            E.g. for <img src="tobereplaced.jpg" tridion:href="tcm:6-543" tridion:type="Multimedia" tridion:targetattribute="src"/>the existing image element
            is preserved, but the tridion: attributes are removed and the src attribute value is set to the published path (it is an error if that binary is
            not in the package).
            
            Current required inputs in the package: - The 'Output' variable must contain the HTML as described above. - The 'Page' must contain the context
            page (to determine the relevant page and publication URIs) - If tridion:type="Multimedia", the binary referenced by tridion:href must be in the
            package and must have been published.
            
            The output in the package consists of the replaced 'Output', with the tags with tridion:href attributes replaced by a resolved links (possibly
            TCDL, possibly target directly written into the output).
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeNameTridionHref">
            <summary>
            The href attribute (used in created tridion hyperlinks)
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeNameTridionType">
            <summary>
            The type attribute, used to indicate the type of tridion hyperlink
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeTridionTypeComponent">
            <summary>
            type attribute value for component-links
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeTridionTypePage">
            <summary>
            type attribute value for page-links
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeTridionTypeMultimedia">
            <summary>
            type attribute value for binary-links
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeNameTargetAttribute">
            <summary>
            Attribute name for the attribute the eventual link value should be placed in
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeNameTridionTextOnFailure">
            <summary>
            Attribute name for the attribute with the missing link text
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeNameTridionExcludeTemplateUri">
            <summary>
            Attribute name for the attribute with the component template to exclude in component links
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeNameTridionAnchor">
            <summary>
            Attribute name for the attribute with the anchor to use in a link.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AttributeNameTridionVariantId">
            <summary>
            Attribute name for the variantid to use in a link.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of ITemplate interface.
            </summary>
            <param name="engine">The engine used as context for the transformation</param>
            <param name="package">The package serving as in- and output for the transformation.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.GetPageUriFromRenderContext">
            <summary>
            Utility function to get the page URI from the publishing context
            </summary>
            <returns>The page URI of the current publishing action, or null if that could not be determined</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ResolveLinks(System.String)">
            <summary>
            Perform the actual function of this template, by iterating over
            all tags with tridion:href attributes in them and replacing them by (TCDL) linking tags.
            </summary>
            <param name="text">The text to process</param>
            <returns>The processed text (also stored in the member field)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ReplaceCssReferencesInText(System.String)">
            <summary>
            Find all CSS URL references containing TCM URIs in an input text, and replace them with
            their string value.
            </summary>
            <param name="inputText">The text to process</param>
            <returns>The input, with CSS URL references containing TCM URIs replaced by their published
            paths (or error messages if they could not be resolved)</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ProcessLink(System.Text.RegularExpressions.Match)">
            <summary>
            Alter the text output being processed in this template, by
            replacing the <![CDATA[<tagname ....tridion:href....>....</tagname>]]>
            by a
             - <![CDATA[<tcdl:Link>...</tcdl:Link>]]> text, in case of component or page linking.
             - <a href="previewURL">....</a> string in case the render mode is preview
             - <![CDATA[<tag attName="publishedURL>[...</tag>]]]> in case of a multimedia link.
            The changes are made directly on the _text class member variable.
            </summary>
            <param name="matchingTag">A matching start-tag (so not the full tag) which 
            contains at least a tridion:href attribute</param>
            <returns>The altered overall text</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ParseLinkInfo(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Distill all useful information of a hyperlink string, and put the found data
            in a ParsedLinkInfo structure
            </summary>
            <param name="elementName">The name of the element being processed</param>
            <param name="hyperLinkText">The full tag to parse.</param>
            <param name="tagStartPosition">The start-position of hyperLinkText within the full _text</param>
            <param name="endStartTag">Within the hyperLinkText, where end-tag ends</param>
            <returns>A newly created ParsedLinkInfo object with all the found information filled out</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.DetermineTagPositions(System.Text.RegularExpressions.Group,System.String,System.Int32@,System.Int32@)">
            <summary>
            Determine the full tag positions of a tag. The found match only indicates
            the positions of the start-tag (done this way since the end-tag is optional).
            </summary>
            <param name="foundMatch">A regular expression group pointing to a start-tag within _text</param>
            <param name="elementName">The name of the element found</param>
            <param name="tagStartPosition">Result, the start of of the tag</param>
            <param name="tagLength">The length of the full tag, up until the (optional) matching closing tag</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ParseTridionTagAttributes(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Parse a set of HTML attributes (as a string), treating attributes
            with a prefix 'tridion:' special. Those attributes are:
             - Removed from the attributes string.
             - Placed in a map.
            </summary>
            <param name="attributesString">The string to parse, should be of the format
            key="value" key2='value2' key3=value3 tridion:key4 = 'value 5'</param>
            <param name="tridionAttributes">The map in which to place tridion attributes
            as key value pairs. The tridion: prefix is removed from keys</param>
            <returns>The attributesString input, without the tridion attributes found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ParseTridionTagAttributes(System.Text.RegularExpressions.Regex,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Helper for ParseTridionTagAttributes, see its docs for more information
            </summary>
            <param name="regularExpression">The regular expression to use</param>
            <param name="attributesString">The string to parse, should be of the format
            key="value" key2='value2' key3=value3 tridion:key4 = 'value 5'</param>
            <param name="tridionAttributes">The map in which to place tridion attributes
            as key value pairs. The tridion: prefix is removed from keys</param>
            <returns>The attributesString input, without the tridion attributes found</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ProcessExpression(System.String)">
            <summary>
            Process an expression into a value.
            </summary>
            <param name="expression">The expression/ literal to process</param>
            <returns>Returns a determined value. Never returns null, returns
            an empty string if nothing can be determined</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.GetTargetUrl(Tridion.ContentManager.Templating.Package,Tridion.ContentManager.TcmUri)">
            <summary>
            Find a target URL in the package, by looking for a (binary) item
            which has a URI property set to the passed URI, and has an output path
            specified for it.
            </summary>
            <param name="package">The context package to find the binary in</param>
            <param name="tcmUri">The URI of the multimedia component whose binary
            content to look for in the package.</param>
            <returns>The published URL of the item, or a dummy string if that could
            not be resolved.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ResolveLinks(System.Xml.XmlNode)">
            <summary>
            Perform the actual function of this template, by iterating over
            all tags with tridion:href attributes in them and replacing them by (TCDL) linking tags, or filling
            out the binary path reference.
            </summary>
            <param name="document">The template document to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ReplaceLinkNodeWithTCDLNode(System.Xml.XmlNode,Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ParsedLinkInfo)">
            <summary>
            Replace a a href node with a TCDL node (keeping children and attributes)
            Construction build is:
            <![CDATA[<tcdl:Link type="{0}" origin="{2}" destination="{1}" templateURI="{3}" linkAttributes="{7}" textOnFail="{5}" addAnchor="{6}">
              original node content
            </tcdl:Link>]]>
            </summary>
            <param name="foundLinkNode">The link-node to replace</param>
            <param name="linkInfo">The information to use in the construction of the new node</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.AddAttribute(System.Xml.XmlNode,System.String,System.String,System.String)">
            <summary>
            Utility method to add/ replace an attribute on an element (the passed node must be an element)
            </summary>
            <param name="element">The node to add or replace the attribute on</param>
            <param name="name">The fully qualified attribute name</param>
            <param name="namespaceUri">The namespace URI, or null for no namepace</param>
            <param name="value">The value of the new attribute</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ParseLinkInfo(System.Xml.XmlNode)">
            <summary>
            Distill all useful information of a hyperlink node, and remove the existing tridion:
            attributes from the node
            </summary>
            <param name="linkNode">The element node containing a tridion:href attribute being processed</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.LinkResolverTemplate.ParsedLinkInfo">
            <summary>
            Simple structure for data-sharing between the methods in this class
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Templates.ConvertHtmlToXhtmlTemplate">
            <summary>
            Template to perform a TidyNet run on the output item in the package to convert the input to
            XML, and convert the item to XML.
            
            Depends on the presence of a strongly named TidyNet dll
            (see http://sourceforge.net/projects/tidynet/)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ConvertHtmlToXhtmlTemplate.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.Templating.Package)">
            <summary>
            Implementation of ITemplate interface.
            </summary>
            <param name="engine">The engine used as context for the transformation</param>
            <param name="package">The package serving as in- and output for the transformation.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ConvertHtmlToXhtmlTemplate.EncodeTcdlTags(System.String)">
            <summary>
            Scans the input string for tcdl: tags and encodes them into a &lt;div&gt; tag. This is to prevent problems with Tidy
            in the way it deals with custom tags and attributes. 
            </summary>
            <param name="input">input to scan and encode tcdl tags for</param>
            <returns>string that has all tcdl tags from the input encoded as div tags</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ConvertHtmlToXhtmlTemplate.DecodeTcdlTags(System.Xml.XmlDocument)">
            <summary>
            Decodes previously encoded tcdl tags by restoring the original tag described by an attribute in a
            special div tag. the div tag itself is removed.
            </summary>
            <param name="input">document to process</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ConvertHtmlToXhtmlTemplate.SetConfiguration(Tridion.ContentManager.Templating.Package)">
            <summary>
            Set up a configuration for this object. Not completely standard because of the
            API offered.
            </summary>
            <remarks>
            The configured accessibility level, to be used in the ParseString method
            (from the Tidy documentation: 0=Tidy Classic, 1=Priority 1 Checks, 2=Priority 2 Checks,
            3=Priority 3 Checks, see also http://www.aprompt.ca/Tidy/accessibilitychecks.html)
            Does not configure the _itemName, this is done before the full configuration is checked.
            </remarks>
            <param name="package">The package, used to get possible configuration parameters
            from.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ConvertHtmlToXhtmlTemplate.ProcessMessages(System.String)">
            <summary>
            Go over all messages in a collection, sending all warnings and errors
            to the log, and constructing an error message in case there were errors.
            </summary>
            <param name="diagnosticMessagesXml">The XML representation of the messages to process.</param>
            <returns>An error message containing all Tidy's errors and warnings, or
            null if there were no errors</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Templates.ConvertHtmlToXhtmlTemplate.ProcessMessage(System.Xml.XmlNode,System.String)">
            <summary>
            Helper routine for process messages, constructs a message based on a warning
            or error node (and logs it).
            </summary>
            <param name="messageNode">The error or warning-node</param>
            <param name="type">The type of message, used in the generated message</param>
            <returns>A message based on the current node</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplateUtilities">
            <summary>
            This utility class defines various static helper functions for various functionalities of templates.
            </summary>
            <remarks>
            This class acts as a static function library, it is not needed to instantiate it.
            </remarks>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.TridionNamespace">
            <summary>
            Generic Tridion Namespace ("http://www.tridion.com/ContentManager/5.0").
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.TcdlNamespace">
            <summary>
            Namespace associated with the TCDL prefix when Tridion.ContentManager.Templating code
            is used processing output as XML ("http://www.tridion.com/ContentDelivery/5.3/TCDL").
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.TcmXhtmlNamespace">
            <summary>
            Internal namespace used in TcmXhtml diagnostic XML documents.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.TemplateDebuggingNamespace">
            <summary>
            Internal namespace used in package and other documents constructed in the debugger ("http://www.tridion.com/ContentManager/5.3/TemplateDebugging").
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetCharacterEncodingFromContentType(System.String)">
            <summary>
            <para>
            Returns the character encoding embeded into the given content type. If no character encoding is
            specified, this method will return null. The caller should then determine what default encoding it
            wants to use. According to RFC2616 (HTTP 1.1) the default value should be "ISO-8859-1", but the HTML
            4 says that user agents should not assume a default value.
            </para>
            <para>
            For instance for <c>text/html; charset=shift_jis</c> the result is <c>shift_jis</c>.
            </para>
            </summary>
            <remarks>
            Character set names are not case sensitive, so any code using the return value from this
            method must not do case sensitive matches or checks.
            </remarks>
            <param name="contentType">the content type from which to return the character encoding.</param>
            <returns>the character encoding specified in the given content type or null if the content type
            doesn't specify a character encoding.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetRegexMatches(System.String[],System.Text.RegularExpressions.Regex)">
            <summary>
            Get an Iterator of all matching locations in a text string, for a specific
            regular expression.
            The text (in the <c>textContainer</c> argument) may be changed *after*
            the position where the last match was found during the loop.
            (The regular expression is applied to all text, after each match the scan is restarted
            after that).
            </summary>
            <remarks>This method can be used to loop over constructs in a text.</remarks>
            <param name="textContainer">The string to look in for strings. Changes in the string may
            occur during the iteration. The value is passed as an array so that the changed value is used
            in progressive searches(ref keyword is not allowed in these types of methods).</param>
            <param name="regularExpression">The regular expression to match on the string</param>
            <returns>An enumerator of match positions in the form of Matches.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.CheckParameterNotNull(System.Object,System.String)">
            <summary>
            Utility method to throw a TridionArgumentNullException in case
            a passed parameter is null.
            </summary>
            <param name="parameterValue">The value to check for null.</param>
            <param name="parameterName">The name of the parameter, used in the thrown exception.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.LoadAssembly(Tridion.ContentManager.Templating.Engine,System.Byte[],System.String)">
            <summary>
            Load an assembly, based on a file, taking into account a possible pdb symbol file to
            load along with the assembly.
            </summary>
            <param name="engine">Reference to the context engine</param>
            <param name="assemblyContent">The assembly to load as a byte array</param>
            <param name="assemblyFileName">File name of the assembly</param>
            <returns>The loaded assembly</returns>
            <exception cref="T:Tridion.ContentManager.Templating.TemplatingException">In case the assembly could not be loaded</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.ReadFile(System.String)">
            <summary>
            Utility method to read a file into a byte-array.
            </summary>
            <param name="path">The file to load</param>
            <returns>The content of the file (it is an error if the file does not exist)</returns>
            <exception cref="T:System.IO.IOException">In case the file could not be properly read</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.ReadStream(System.IO.Stream,System.String)">
            <summary>
            Utility method to read a stream into a byte-array.
            </summary>
            <param name="stream">The stream to stream</param>
            <param name="streamName">The name of the stream to be used in error messages</param>
            <returns>The content of the stream</returns>
            <exception cref="T:System.IO.IOException">In case the streamcould not be properly read</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.SavePDBFile(System.Byte[],System.String)">
            <summary>
            Write a PDB file to disk, using the templating configuration to determine the
            location of that file
            </summary>
            <param name="pdbContents">The contents of the file to write (not null)</param>
            <param name="assemblyName">A valid assembly name, used in the file name</param>
            <returns>The file location of the saved file</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.LoadAssemblyResource(System.Reflection.Assembly,System.String)">
            <summary>
            Loads a Resource from a given resource location.
            </summary>
            <param name="assembly">A reference to the executing contexts assembly</param>
            <param name="resourceKey">The key to the resource to load.</param>
            <returns>String representation of the resource or empty string if resource with the specified key was not found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetTemplatingSettings">
            <summary>
            Get the templating configuration, as specified in the <c>tridion.templating</c> section
            of the <c>Tridion.ContentManager.config</c> configuration file.
            </summary>
            <returns>The templating configuration object (never null).</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetTemplateTypeIdentifiers">
            <summary>
            Determine the default template type identifiers in the currently configured environment.
            </summary>
            <returns>A map of template type enum value to configured integers. For default template types
            where are value could not be found for, -1 is present in the map.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetTemplateTypeIdentifier(Tridion.ContentManager.Templating.TemplateUtilities.DefaultTemplateTypes,System.Int32)">
            <summary>
            Determine the the template type identifier for a type of templates templates.
            </summary>
            <param name="templateType">The type of template to get an identifier for</param>
            <param name="defaultValue">The default identifier, in case none is configured</param>
            <returns>The template type of the requested template type</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.Log(System.Diagnostics.TraceEventType,System.String)">
            <summary>
            Log a message. Since may be used in a setup where logging is not configured,
            the message for now is logged directly to the console.
            </summary>
            <param name="severity">The severity of the message</param>
            <param name="message">The message to log</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.CreateTcmUriForPublication(System.Int32,Tridion.ContentManager.TcmUri)">
            <summary>
            Creates a copy of the given TCM URI changing its publication id to the given publication id.
            </summary>
            <remarks>
                <para>
                    This method performs no checks on the input parameters.
                </para>
                <para>
                    This method handles both versioned and versionless URIs.
                </para>
            </remarks>
            <param name="referencePublicationId">The publication id to use</param>
            <param name="uriToFix">The URI to change</param>
            <returns>A new TCM URI that is the same as <paramref name="uriToFix"/> but with <paramref name="referencePublicationId"/> as the publication id.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.FixPublicationId(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri)">
            <summary>
            Ensure the publication id of an uri to fix matches the publication id of a reference URI.
            </summary>
            <remarks>
            This method is useful to ensure all objects are retrieved from the same publication, in
            situations where the URI need not be localized.
            </remarks>
            <param name="referenceUri">The URI to take the publication id from (may be null).</param>
            <param name="uriToFix">The URI to fix up (may be null).</param>
            <returns>A possibly new <c>TcmUri</c> based on <c>uriToFix</c> that has the same publication id
            as the <c>referenceURI</c>.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetPublicationId(Tridion.ContentManager.TcmUri)">
            <summary>
            Determine the publication id from a <c>TcmUri</c>.
            </summary>
            <param name="uri">The URI to retrieve the publication id from.</param>
            <returns>The publication id of to the URI.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.SerializeXml(System.Xml.XmlNode)">
            <summary>
            Serialize an XmlElement to a string.
            </summary>
            <param name="node">The XML node to serialize</param>
            <returns>The string representation of the Xml node</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.CreateDocumentFromString(System.String)">
            <summary>
            Utility method to construct an XML DOM from an XML input string.
            </summary>
            <remarks>
            This method is different from the standard XML parsing functions in that
            it uses an internal catalog of common HTML DTDs.
            </remarks>
            <param name="xmlString">The XML string to parse.</param>
            <returns>An XMLDocument representation of the xmlString.</returns>
            <exception cref="T:System.Xml.XmlException">In case the document can not be read as XML.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.CreateDocumentFromStream(System.IO.Stream)">
            <summary>
            Utility method to construct an XML DOM from an XML input stream.
            </summary>
            <remarks>
            This method is different from the standard XML parsing functions in that
            it uses an internal catalog of common HTML DTDs.
            </remarks>
            <param name="xmlStream">The XML stream to parse</param>
            <returns>An XMLDocument representation of the xmlStream or xmlString.</returns>
            <exception cref="T:System.Xml.XmlException">In case the document can not be read as XML.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.SelectSingleNode(System.Xml.XmlNode,System.String)">
            <summary>
            Execute an XPath expression on a node returning the first matching node, with
            several Tridion related namespaces set up.
            </summary>
            <remarks>
            In writing XPath expressions, remember that XHTML elements need not be in
            a namespace as far  as can be determined (so xpath expressions have to take
            that into account).
            </remarks>
            <param name="node">The node that acts as the context for the query.</param>
            <param name="xpath">The XPath expression to execute.</param>
            <returns>The first matching node for the XPath expression.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.SelectNodes(System.Xml.XmlNode,System.String)">
            <summary>
            Execute an XPath expression on a node, with a several Tridion related namespaces
            set up.
            </summary>
            <remarks>
            In writing XPath expressions, remember that XHTML elements need not be in
            a namespace as far  as can be determined (so xpath expressions have to take
            that into account).
            </remarks>
            <param name="node">The node that acts as the context for the query.</param>
            <param name="xpath">The XPath expression to execute.</param>
            <returns>The matching nodes.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.SelectNodes(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Execute an XPath expression on a navigator node, with a several Tridion related namespaces
            set up.
            </summary>
            <remarks>
            In writing XPath expressions, remember that XHTML elements need not be in
            a namespace as far  as can be determined (so xpath expressions have to take
            that into account).
            </remarks>
            <param name="node">The navigator node that acts as the context for the query.</param>
            <param name="xpathQuery">The XPath expression to execute.</param>
            <returns>The matching nodes.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetTcmUriFromTridionXml(System.String)">
            <summary>
            Utility method to extract the TcmUri of a Tridion XML representation
            of a Tridion item.
            </summary>
            <param name="tridionXml">The XML representation of a Tridion item.</param>
            <returns>The TCM URI of the item extracted from the XML.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.ResolveRichTextFieldXhtml(System.String)">
            <summary>
            Perform ResolveXHTML on a RTF field content, matching the function in the
            VBScript Default Template Building Block.
            </summary>
            <remarks>
            'img' and 'a' tags with an <c>xlink:href</c> attribute are processed:
            <list type="bullet">
             <item>For images the <c>xlink:href</c> attribute is copied to the <c>src</c>-attribute.</item>
             <item>For a-tags, a <c>tridion:href</c> attribute is introduced.</item>
            </list>
            In both cases, the <c>xlink:*</c> attributes on the found elements are removed, and
            <see cref="M:Tridion.ContentManager.Templating.TemplateUtilities.StripXhtml(System.Xml.XmlDocument)"/> is used to clean up the result.
            </remarks>
            <param name="inputXhtml">An Xhtml fragment, meant to be a RTF field value.</param>
            <returns>A processed version of the <c>inputXhtml</c>.</returns>
            <exception cref="T:System.Xml.XmlException">In case the input parameter is not an Xhtml fragment.</exception>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.StripXhtml(System.Xml.XmlDocument)">
            <summary>
            Perform <c>StripXHTML</c> on a document, matching the function in the
            VBScript Default Template Building Block.
            </summary>
            <remarks>
            The most important function is to remove xhtml related namespace declarations.
            </remarks>
            <param name="document">The document to transform.</param>
            <returns>The processed document.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.CreateTidyConfigurationData(System.Xml.XmlDocument,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Transforms an xml based version of a Tidy configuration file into an ini style based one expected by the TidyXHtml api.
            </summary>
            <param name="tidyConfiguration">An xml based tidy configuration file.</param>
            <returns>The path to an ini style Tidy configuration file</returns>
            <param name="tidyOverideOptions">Constains a sorted list of options that should be used to overide the default configuration options.
             The key is the tidy option that should be overiddden, for example "show-body-only".
             The value is the value that should be used instead of the default - e.g 'true' to replace a default value of 'false'
            </param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetTidyObject(System.Xml.XmlDocument,System.Collections.Generic.SortedDictionary{System.String,System.String})">
            <summary>
            Returns a thread safe configured Tidy object to the caller.
            </summary>
            <remarks>
            The passed in configuration options determine if a new Tidy object is returned.
            When the parameters passed in match those of a previously requested Tidy object the previously inserted and configured one is returned.
            This will minimise the performance impact of loading the configuration from disk every time a caller such as
            the ConvertHTMLToXHTML template building block is invoked in say a page template with 10 component presentations
            </remarks>
            <param name="tidyConfiguration">The xml based tidy configuration file.</param>
            <param name="tidyOverideOptions">The tidy overide options.</param>
            <returns>A TidyObject configured for use in a Tidy operation</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplateUtilities.GetTempFilePath">
            <summary>
            Get a temporary file location that can be shared with DLLHost's user.
            </summary>
            <remarks>
            <para>
            This method was added for TT59463. The goal is to create a temporary file location.
            But <c>Path.GetTempFileName()</c> can create a temporary file in a user specific
            temporary directory (e.g. <c>C:\DocumentsAndSetttings\DEV53TESTW2K\ASPNET\Local Settings\Temp</c>),
            not accesssible by other users, while the storing of the assembly template is performed in
            the COM+ Tridion application (DLLHost.exe running as another user).
            </para>
            <para>
            Several directories were considered. In the end a choice was made to use the Upload directory
            of the Content Creation GUI. This has the advantage that it does not have to be explicitly
            configured (figured out from the web context), and that its security settings are already
            set up for access from the DLLHost process (also for this goal, for making binary items
            with the TOM).
            </para>
            <para>
            If something goes wrong setting up a temporary file in the upload directory (e.g. simply because
            the Upload directory is not there), fall back to <c>GetTempFileName</c> path.
            </para>
            </remarks>
            <returns>A path to a created temporary file</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplateUtilities.DefaultTemplateTypes">
            <exclude/>
            <summary>
            Enum used in GetTemplateTypeIdentifiers result (excluded from API documentation because
            at best is very miscelleneous usage of the API).
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.DefaultTemplateTypes.CompoundTemplate">
            <summary>
            Compound Template
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.DefaultTemplateTypes.CSharpFragmentTemplate">
            <summary>
            C# Fragment Template
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.DefaultTemplateTypes.AssemblyTemplate">
            <summary>
            Assembly Template
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplateUtilities.DefaultTemplateTypes.DreamweaverTemplate">
            <summary>
            Dreamweaver Template
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplatingException">
            <summary>
            Common base exception used everywhere in templating. This exception may be thrown by 
            Templating, template programmers will usually not throw these exceptions themselves.
            </summary>
            <remarks>
            Templating exception are localized for various languages.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingException.#ctor(System.String)">
            <summary>
            Constructor for simple message only.
            </summary>
            <param name="resourceName">The name of the message-resource</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingException.#ctor(System.String,System.Object[])">
            <summary>
            Constructor for parameterized message.
            </summary>
            <param name="resourceName">The name of the message-resource</param>
            <param name="parameters">List of parameters to use in the message.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingException.#ctor(System.String,System.Exception,System.Object[])">
            <summary>
            Constructor for parameterized message with wrapped exception.
            </summary>
            <param name="resourceName">The name of the message-resource</param>
            <param name="innerException">The wrapped exception</param>
            <param name="parameters">List of parameters to use in the message.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingException.#ctor(System.String,System.Exception,System.Diagnostics.TraceEventType,System.Object[])">
            <summary>
            Constructor for parameterized message, with wrapped exception, and specifying an event type.
            </summary>
            <param name="resourceName">The name of the message-resource</param>
            <param name="innerException">The wrapped exception (may be null)</param>
            <param name="eventType">The type of event this exception represents (default is error)</param>
            <param name="parameters">List of parameters to use in the message.</param>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TemplatingRenderer">
            <summary>
            Engine implementation class that acts as intermediate between the Publishing renderer and
            Templating. Do not use this class directly, use <see cref="T:Tridion.ContentManager.Templating.Engine"/> instead.
            </summary>
        </member>
        <member name="F:Tridion.ContentManager.Templating.TemplatingRenderer._renderedItem">
            <summary>
            References passed to the Render method call, context of publishing action.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.#ctor">
            <exclude/>
            <summary>
            Empty constructor (so also no session set)
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.Render(Tridion.ContentManager.Publishing.Resolving.ResolvedItem,Tridion.ContentManager.Publishing.PublishInstruction,Tridion.ContentManager.CommunicationManagement.PublicationTarget,Tridion.ContentManager.Publishing.Rendering.RenderedItem,Tridion.ContentManager.Publishing.Rendering.RenderContext)">
            <summary>
            Implementation of IRenderer.
            </summary>
            <param name="resolvedItem">The item to render</param>
            <param name="instruction">The rendering parameters</param>
            <param name="target">The publication target the rendering will occur to</param>
            <param name="renderedItem">The item that is the result of this rendering</param>
            <param name="renderContext">The render context of this rendering action</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.GetContextPublicationUri">
            <summary>
            Method that determines the current publication where engine is executing within.
            </summary>
            <returns>The Tcm URI of the context publication, or <c>null</c> if this cannot be determined</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.CheckInitialized">
            <summary>
            Check whether the API-calls of the engine may be used.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.IsTemplateDynamic(Tridion.ContentManager.CommunicationManagement.ComponentTemplate)">
            <summary>
            Override determining whether a component template should be treated as dynamic,
            taking into account the publication target.
            </summary>
            <param name="template">The template to inspect</param>
            <returns>Whether the template should be rendered in dynamic fashion</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.SetupRenderInstruction(Tridion.ContentManager.Publishing.RenderInstruction)">
            <summary>
            Implementation of SetupRenderInstruction.
            </summary>
            <param name="renderInstruction">The render instruction to process</param>
            <returns>The publication target used for this publishing action</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.GetMainRenderedItem">
            <summary>
            Return the rendered item that this render action uses.
            </summary>
            <returns>The renderered item the Templating Renderer was instantiated for</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.AddBinary(Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri,Tridion.ContentManager.TcmUri,System.Byte[],System.String)">
            <summary>
            Publish a binary from a byte-array with a given filename, associated with a multimedia
            component and possibly saved as a variant (the template uri acts as a variant).
            </summary>
            <remarks>
            For more AddBinary alternatives, use 
            <c>Engine.PublishingContext.<see cref="T:Tridion.ContentManager.Publishing.Rendering.RenderedItem"/>.AddBinary(...)</c>.
            </remarks>
            <param name="componentUri">The multimedia component this item refers to</param>
            <param name="templateUri">The template in whose context this AddBinary call is executed (used as variant id)</param>
            <param name="targetLocation">The location to publish the binary to (if null, publish to standard path)</param>
            <param name="data">The binary data to publish</param>
            <param name="fileName">The filename to publish the file under</param>
            <returns>The path of the binary as it was published to</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.AddBinary(Tridion.ContentManager.Templating.Item,Tridion.ContentManager.TcmUri)">
            <summary>
            Publish a binary from a given Multimedia Item.
            </summary>
            <remarks>
            For more AddBinary alternatives, use 
            <c>Engine.PublishingContext.<see cref="T:Tridion.ContentManager.Publishing.Rendering.RenderedItem"/>.AddBinary(...)</c>.
            </remarks>
            <param name="multimediaItem">The multimedia item in the package to publish</param>
            <param name="targetLocation">The location to publish the binary to if the item does not specify.</param>
            <returns>The path of the binary as it was published to</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.WriteRenderedItemContent(Tridion.ContentManager.Publishing.Rendering.RenderedItem,Tridion.ContentManager.Templating.Item)">
            <summary>
            Write (add) string content to a rendered item
            </summary>
            <param name="renderedItem">The item to add the content to</param>
            <param name="contentItem">The content to add</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TemplatingRenderer.CanHandleResolvedItem(Tridion.ContentManager.Publishing.Resolving.ResolvedItem)">
            <summary>
            Check if this renderer knows how to render this <see cref="T:Tridion.ContentManager.Publishing.Resolving.ResolvedItem"/>.
            </summary>
            <param name="resolvedItem">The resolved item to render.</param>
            <returns><see langword="true"/> if this renderer can render the <see cref="T:Tridion.ContentManager.Publishing.Resolving.ResolvedItem"/>, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TemplatingRenderer.RenderMode">
            <summary>
            The RenderMode of the current publishing action.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TidyObjectCache">
            <summary>
            Provides a thread safe cache of pre-initialized Tidy Objects.
            </summary>
            <remarks>
            Will be used to limit the performance impact of having to create a file based 
            configuration file per invocation of a template building block.
            An example use for this cache is in the ConvertHtmlToXml building block.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TidyObjectCache.FlushCache">
            <summary>
            Clears the TidyObject Cache
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.TidyObjectCache.ThreadInstance">
            <summary>
            Returns the instance of the TidyObjectCache.
            </summary>
            <value>The instance for current thread.</value>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TridionObjectSource">
            <summary>
            Representation of a Tridion object (read-only) as a Source
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.#ctor(Tridion.ContentManager.IdentifiableObject,Tridion.ContentManager.Templating.Engine)">
            <summary>
            Constructor for a TridionObject source, based on existing object.
            </summary>
            <param name="item">The Tridion item this object will represent</param>
            <param name="engine">The context engine</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.#ctor(Tridion.ContentManager.TcmUri,Tridion.ContentManager.Templating.Engine)">
            <summary>
            Constructor for a TridionObject source, based on Uri.
            </summary>
            <param name="itemUri">The uri of the item this object is to represent</param>
            <param name="engine">The context engine</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetMetaDataAsSource">
            <summary>
            The meta-data of the Tridion item, as a source.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetComponentFieldsAsSource">
            <summary>
            The field-data of the component, as a source.
            Throws an exception for other kinds of objects.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetDefaultValue">
            <summary>
            Determine a representing string value that describes the Tridion object
            the item represents.
            Used to determine a default value for the object.
            </summary>
            <returns>A representing string-value for the underlying Tridion object</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetTridionObject(Tridion.ContentManager.TcmUri)">
            <summary>
            Utility method to instantiate a Tridion object for a specified URI.
            </summary>
            <param name="tcmUri">The URI to create the object for</param>
            <returns>A newly instantiated Tridion object, or null
            if no object could be found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSources(System.String)">
            <summary>
            Retrieve the (list of) subsource(s) of a source. The returned subsource(s)
            can be used again to drill down the expression further.
            
            For example, if calling GetValue("Component.Schema.ID") on a source
            would return a value, calling
            	GetSources("Component.Schema")[0].GetValue("ID")
            would result in the same.
            </summary>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of subsources that match the partially qualified name. Most implementations
            of this method will not return all possible matches, but just the list of sources of the first
            match found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetValue(System.String)">
            <summary>
            Determine the string value for a source.
            </summary>
            <param name="fullyQualifiedName">The name to get the source for</param>
            <returns>The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetContentType">
            <summary>
            Implementation of ISource.GetContentType interface.
            </summary>
            <returns>The content type matching the Tridion item represented</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSourcesForPage(System.String)">
            <summary>
            Implementation of ISource for pages.
            </summary>
            <param name="fullyQualifiedName">The name to retrieve a value for</param>
            <returns>The source(s) retrieved, or an empty list if this is no match.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSourcesForSchema(System.String)">
            <summary>
            Implementation of ISource for schema.
            </summary>
            <param name="fullyQualifiedName">The name to retrieve a value for</param>
            <returns>The source(s) retrieved, or an empty list if this is no match.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSourcesForTemplate(System.String)">
            <summary>
            Implementation of ISource for template.
            </summary>
            <param name="fullyQualifiedName">The name to retrieve a value for</param>
            <returns>The source(s) retrieved, or an empty list if this is no match.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSourcesForPublication(System.String)">
            <summary>
            Implementation of ISource for publication.
            </summary>
            <param name="fullyQualifiedName">The name to retrieve a value for</param>
            <returns>The source(s) retrieved, or an empty list if this is no match.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSourcesForComponent(System.String)">
            <summary>
            Implementation of ISource for component.
            </summary>
            <param name="fullyQualifiedName">The name to retrieve a value for</param>
            <returns>The source(s) retrieved, or an empty list if this is no match.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSourcesForSchemaOfItem(System.String,System.String)">
            <summary>
            Attempt to determine value (for a source) through it's
            schema. It is not determined that schema of the item should
            in fact be used in the resolution.
            </summary>
            <param name="name">The first part of the fully qualified name to resolve</param>
            <param name="subQualifiedName">The fully qualified to resolve minus the first part.</param>
            <returns>The source(s) retrieved, or an empty list if this is no match.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetSourcesForPublicationOfItem(System.String,System.String)">
            <summary>
            Attempt to determine value (for a source) through it's
            publication. It is not determined that the publication
            of the item should in fact be used to in the resolution.
            </summary>
            <param name="name">The first part of the fully qualified name to resolve</param>
            <param name="subQualifiedName">The fully qualified to resolve minus the first part.</param>
            <returns>The source(s) retrieved, or an empty list if this is no match.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetIterationFieldSources(System.String,System.String,System.Boolean)">
            <summary>
            Check whether this is a request for 'Fields' or 'Metadata', to iterate over
            the (meta-)fields of the tridion item.
            </summary>
            <param name="primaryName">The first name of the source being requested</param>
            <param name="subQualifiedName">The remainder of the source expression</param>
            <param name="isComponent">Whether the current item should be treated as a component</param>
            <returns>null in case there is no match on 'Fields' or 'Metadata' (the common case),
            or a (possibly still empty) list of matching resources.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.TryResolveSource(System.String,System.Collections.Generic.IList{Tridion.ContentManager.Templating.ISource}@,System.String,System.String[])">
            <summary>
            Utility method to quickly set a result variable if a match is found,
            to simplify the GetValue methods.
            </summary>
            <param name="foundValue">The value to set, if null no change is made</param>
            <param name="result">The variable to set the foundValue (in a source list) to, should be null since it
            might be set in this method</param>
            <param name="name">The name to match against the names to match parameter to check</param>
            <param name="namesToMatch">A variable set of arguments representing names of
            parameters. If no namesToMatch are provided, there is always a match</param>
            <returns>Whether or not the result variable was set</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.TryResolveMetaValueSource(Tridion.ContentManager.Templating.ISource,System.Collections.Generic.IList{Tridion.ContentManager.Templating.ISource}@,System.String[])">
            <summary>
            Variant of ResolveSource that is aimed specifically at field-values.
            In case one of the namesToMatch is present as a key in the fields,
            the variable result is set to the field value, and true is returned.
            </summary>
            <param name="fields">The fields-source to match the names with</param>
            <param name="result">The variable to set the found value to (in a source list), 
            should be null since it might be set in this method</param>
            <param name="namesToMatch">The name or names to match</param>
            <returns>Whether the result variable was set by this method</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetStringValue(Tridion.ContentManager.ContentManagement.Fields.ItemFields,System.String)">
            <summary>
            Get the string value of a field
            </summary>
            <param name="fields">The fields-set to look in</param>
            <param name="fieldName">The name of the field to find</param>
            <returns>The value of the field, or null if the field cannot be found
            or has no value</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetStringValue(Tridion.ContentManager.ContentManagement.Fields.ItemField)">
            <summary>
            Get the string value of a field
            </summary>
            <param name="field">The field to determine the value for</param>
            <returns>The value of the field, or null if the field has no value. For multivalue
            fields, the values are simply concatenated</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetBasicItemFieldSources(Tridion.ContentManager.ContentManagement.Fields.ItemField)">
            <summary>
            Get the values of a field as strings.
            All types of fields are converted to strings. Multiple values are
            simply concatenated
            </summary>
            <param name="field">The field to retrieve the value for</param>
            <returns>A (possibly empty) list of of values, or null in case the field
            could not be processed at all</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.GetFieldsAsSource(System.Xml.XmlElement,Tridion.ContentManager.ContentManagement.Schema)">
            <summary>
            Get the fields of a the current item (either meta-data or component data) as a source
            </summary>
            <param name="fieldData">The field-data as XML</param>
            <param name="fieldSchema">The schema defining the XML</param>
            <returns>A source representation of the fields</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.TridionObjectSource.BasicFieldSource">
            <summary>
            Extension of StringSource that answers with Me.ContentType with the content type as a string
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.BasicFieldSource.GetSources(System.String)">
            <summary>
            Retrieve the (list of) subsource(s) of a source. The returned subsource(s)
            can be used again to drill down the expression further.
            
            For example, if calling GetValue("Component.Schema.ID") on a source
            would return a value, calling
            	GetSources("Component.Schema")[0].GetValue("ID")
            would result in the same.
            </summary>
            <param name="partiallyQualifiedName">The name to get the source for</param>
            <returns>A list of subsources that match the partially qualified name. Most implementations
            of this method will not return all possible matches, but just the list of sources of the first
            match found.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.TridionObjectSource.BasicFieldSource.GetValue(System.String)">
            <summary>
            Determine the string value for a source.
            </summary>
            <param name="fullyQualifiedName">The name to get the source for</param>
            <returns>
            The value found, or null if no value was found. If multiple values match
            the name, values are usually concatenated with a ','.
            </returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Xslt.XsltExtensionAttribute">
            <summary>
            Attribute for marking types, which can be used as extension objects in Xslt transformation.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XsltExtensionAttribute.Namespace">
            <summary>
            Gets or sets the namespace URI to associate with the extension object during Xslt transformation.
            </summary>
            <value>
            The namespace URI to associate with the extension object.
            </value>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Xslt.TcmUriResolver">
            <summary>
            Customized XmlUrlResolver to load the XML SDLTridion Items by URI
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.TcmUriResolver.#ctor(Tridion.ContentManager.Templating.Engine)">
            <summary>
            Initializes a new instance of the <see cref="T:Tridion.ContentManager.Templating.Xslt.TcmUriResolver"/> class.
            </summary>
            <param name="templateEngine">The template engine.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.TcmUriResolver.GetEntity(System.Uri,System.String,System.Type)">
            <summary>
            Maps a URI to an object containing the actual resource.
            </summary>
            <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)"/></param>
            <param name="role">The current implementation does not use this parameter when resolving URIs. This is provided for future extensibility purposes. For example, this can be mapped to the xlink:role and used as an implementation specific argument in other scenarios.</param>
            <param name="ofObjectToReturn">The type of object to return. The current implementation only returns System.IO.Stream objects.</param>
            <returns>
            A System.IO.Stream object or null if a type other than stream is specified.
            </returns>
            <exception cref="T:System.Xml.XmlException">
              <paramref name="ofObjectToReturn"/> is neither null nor a Stream type. </exception>
            <exception cref="T:System.UriFormatException">The specified URI is not an absolute URI. </exception>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="absoluteUri"/> is null. </exception>
            <exception cref="T:System.Exception">There is a runtime error (for example, an interrupted server connection). </exception>
            <remarks>
            <para>
            For all Tridion items, except TemplateBuildingBlock, returns their R5 xml. For TemplateBuildingBlocks returns its content.
            </para>
            </remarks>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Xslt.XsltMediator">
            <summary>
            This class interprets a Xslt template.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltMediator.Transform(Tridion.ContentManager.Templating.Engine,Tridion.ContentManager.CommunicationManagement.Template,Tridion.ContentManager.Templating.Package)">
            <summary>
            Execute the specified template in the context of the given package.
            The mediator is expected to be able to handle the template, as it is called
            based on the template types configuration.
            </summary>
            <param name="engine">The engine invoking the templating</param>
            <param name="templateToTransform">The template to execute</param>
            <param name="package">The package with both the inputs and the outputs of the template</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltMediator.Configure(Tridion.ContentManager.Templating.Configuration.MediatorElement)">
            <summary>
            Configure the mediator
            </summary>
            <param name="configuration">The configuration element for this mediator</param>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XsltMediator.Engine">
            <summary>
            Gets or sets templating engine.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XsltMediator.Package">
            <summary>
            Gets or sets the package - representation of the context of a transformation.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Xslt.XslTransformInfo">
            <summary>
            Contains information related to Xslt transformation of the template.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XslTransformInfo.Transformer">
            <summary>
            Gets or sets the transformer for xml transformation.
            </summary>
            <value>
            The <see cref="T:System.Xml.Xsl.XslCompiledTransform"/> object.
            </value>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XslTransformInfo.OutputName">
            <summary>
            Gets the name of the output item after transformation.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XslTransformInfo.InputName">
            <summary>
            Gets the name of the item in package, which will be transformed.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XslTransformInfo.ExtensionTbbId">
            <summary>
            Gets the uri of the assembly template building block, which can be used during Xslt transformation.
            </summary>
            <remarks>
            If property is defined, types from assembly(from Binary content) will be attached to transformer, as extension objects during transformation. 
            </remarks>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XslTransformInfo.ContentType">
            <summary>
            Gets the <see cref="P:Tridion.ContentManager.Templating.Xslt.XslTransformInfo.ContentType"/> of the output item.
            </summary>
        </member>
        <member name="P:Tridion.ContentManager.Templating.Xslt.XslTransformInfo.DeclaredParams">
            <summary>
            Gets the list of declared parameters in xslt template.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler">
            <summary>
            Template Content Handler for XSLT Templates.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler.#ctor(Tridion.ContentManager.TcmUri)">
            <summary>
            Create a new Template Content Handler instance for a given Template Id.
            </summary>
            <param name="templateId">The ID (TCM URI) of the Template of which the content should be processed.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler.ValidateContent">
            <summary>
            Validate the Template's content.
            </summary>
            <remarks>
            Performs basic validation on the XSLT and validates that all references contain either a TCM URI of a TBB or a WebDAV URL.
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler.ExtractReferences">
            <summary>
            Extract references to (potential) TCM items from the Template's content.
            </summary>
            <returns>An array of URIs (either TCM URIs or WebDAV URLs) of potential TCM items.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler.SubstituteReferences(System.String[])">
            <summary>
            Substitute references to TCM items in the Template's (binary) content.
            </summary>
            <param name="newReferences">
            An array of URIs (either TCM URIs or WebDAV URLs) to substitute.
            The number of elements and order of the elements in the array corresponds to the array returned by <see cref="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler.ExtractReferences"/>.
            Extracted reference which turned out not to point to an existing TCM item will have a <c>null</c> newReference.
            </param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler.InternalExtractReferences(System.Boolean)">
            <summary>
            Parse the XSLT and extract references.
            </summary>
            <param name="validate">Indicates whether the XSLT and reference TCM URIs should be validated.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateContentHandler.AssertValidXslt">
            <summary>
            Raises an exception if the the XSLT isn't valid.
            </summary>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Xslt.XsltTemplateHelper">
            <summary>
            Provides functionality to xslt templates by exposing methods that can be called 
            during the transformation.
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateHelper.#ctor(Tridion.ContentManager.Templating.Engine)">
            <summary>
            Initializes a new instance of the <see cref="T:Tridion.ContentManager.Templating.Xslt.XsltTemplateHelper"/> class.
            </summary>
            <param name="templateEngine">The templating Engine, context for the templating code.</param>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateHelper.GetFormattedDate(System.String,System.String)">
            <summary>
            Gets formatted date using sortable format.
            </summary>
            <param name="inputDate">The input in string representation.</param>
            <param name="dateFormat">Desired format for input string.</param>
            <returns>Date in desired string format.</returns>
            <example>
            xmlns:txh="http://www.sdltridion.com/ContentManager/XsltTemplateHelper/"
            &lt;xsl:value-of select="txh:GetFormattedDate(//tcm:CreationDate, 'dddd, MMM dd, yyyy')"&gt;
              </example>
            <remarks>
            Assumed, that input date string will be in sortable format.
            http://msdn.microsoft.com/en-us/library/az4se3k1.aspx#Sortable"
            </remarks>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateHelper.GetListItems(System.String)">
            <summary>
            Gets list of items within an organizational item.
            </summary>		
            <example> 
                    xmlns:txh="http://www.sdltridion.com/ContentManager/XsltTemplateHelper/"
            		&lt;xsl:variable name="FolderItems" select="txh:getListItems(//tcm:OrganizationalItem/@xlink:href)"/&gt;
            			&lt;xsl:for-each select="$FolderItems//tcm:Item[@Type='16']"&gt;
            				&lt;xsl:value-of select="@Title"/&gt;&lt;br/&gt;
            			&lt;/xsl:for-each&gt;
             </example>
            <param name="orgItemId">TcmUri/WebDavUrl of the organizational item.</param>
            <returns><see cref="T:System.Xml.XmlDocument"/> containing a list of child items for the org item.</returns>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTemplateHelper.GetMultimediaInfo(System.String)">
            <summary>
            Gets information about the MM component such as the mime type or extension.
            </summary>
            <param name="id">TcmUri of a multimedia component.</param>
            <example>
            xmlns:txh="http://www.sdltridion.com/ContentManager/XsltTemplateHelper/"
            &lt;xsl:value-of select="txh:GetMultimediaInfo('tcm:10-12')"&gt;
            </example>
            <returns>Returns information about multimedia type and its binary content in xml representation.</returns>
        </member>
        <member name="T:Tridion.ContentManager.Templating.Xslt.XsltTransformInfoCache">
            <summary>
            AppDomain-wide caching mechanism for caching <see cref="T:Tridion.ContentManager.Templating.Xslt.XslTransformInfo"/> objects (XslCompiledTransform for input template and other parameters, which are required during transformation).
            </summary>
        </member>
        <member name="M:Tridion.ContentManager.Templating.Xslt.XsltTransformInfoCache.CreateTemplateKey(Tridion.ContentManager.CommunicationManagement.Template)">
            <summary>
            Create a unique key for a given Template version.
            </summary>
            <param name="template">The Template (version) for which to get a cache key.</param>
            <returns>The template key used to cache an xslt transformer for the given Template version.</returns>
        </member>
    </members>
</doc>
